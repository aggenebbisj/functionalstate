<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom stylesheet -->
    <link rel="stylesheet" href="css/my.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Never change state and still get things done</h1>
            <aside class="notes">Abstract from JFall site
                State can be difficult.
                Concurrent updates can lead to inconsistency, it can be difficult to scale and have you ever tried
                testing a component with a random element without having to resort to mocking?
                Functional purity can help us here.
                In this talk, we are going to investigate how we can design a pure functional structure that abstracts
                over state manipulations.
                We will start with a solution that uses mutable state to solve a problem.
                Then we will refactor step by step and eventually transform it to pure functional code that never
                changes state.
                Familiarity with lambdas is assumed, but no knowledge of functional programming is required.
                Code examples are in Scala, but no advanced language concepts are used, so knowledge of Java 8 is
                sufficient.
                As an audience, I would get a comparative overview of solving a problem in a traditional way with
                imperative code and with pure functional structures.
                I would also learn the benefits of purely functional state and its drawbacks.
            </aside>
        </section>

        <section>
            <h2>Agenda</h2>

            <ul>
                <li>Traditional OO approach</li>
                <li>Transitioning from mutable to immutable</li>
                <li>Immutable with State data structure</li>

            </ul>
        </section>

        <section>
            <section><h2>The domain</h2></section>

            <section data-background-image="/img/candydispenser.jpg"
                     data-background-size="auto 100%"
                     data-background-color="#ffffff">
                <aside class="notes">
                    A vending machine from which you can buy candies.
                    - The vending machine can process two types of inputs from customers.
                    1. They can insert money
                    2. They can turn the knob to get the candy after they inserted the money.
                    - The machine can be refilled with a new stock of candies.
                    - The returns of the machine can be collected, all coins will be extracted.
                </aside>
            </section>


            <section>
                <h3>The code</h3>
                <pre><code class="scala" data-trim data-noescape>
sealed trait Coin
case object Coin extends Coin

case class Candy(color: String)
                    
val candies: List[Candy] = ...
                    </code></pre>
                <aside class="notes">
                    We have a simple economy with just one type of coins, just like a festival.
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h2>The traditional OO approach</h2>
                <img src="/img/object-oriented-software-construction.jpg"/>
                <aside class="notes">
                    who knows this classic writing?
                    First edition written in 1988 by Bertrand Meyer, the second edition at a whopping 1200 pages
                    appeared in 1997
                    "Meyer pursues the ideal of simple, elegant and user-friendly computer languages and
                    is one of the earliest and most vocal proponents of object-oriented programming (OOP).
                    His book Object-Oriented Software Construction is widely considered to be the best work on
                    presenting the case for OOP."
                    https://en.wikipedia.org/wiki/Bertrand_Meyer
                </aside>
            </section>
            <section>
                <h3>A first attempt command query separation</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  private var _lastCandy:Candy = _

  // 'Commands' modify machine
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Unit = { _lastCandy = candies.remove(0) }

  // 'Queries' return information about machine
  def lastCandy = _lastCandy
  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    A ListBuffer is a mutable data structure.
                    Due to command-query separation turn only changes the list of candies and the last candy that was
                    returned.
                    The _(underscore) is necessary to keep the mutable state private.

                    Meyer p. 748 "The features that characterize a class are divided into commands and queries.
                    A command serves to modify objects, a query to return information about objects."
                    p. 749 A function (defined as routine that returns a result) produces a concrete side effect if its
                    body contains any of the following
                    * an assignment, assignment attempt or creation instruction whose target is an attribute * a
                    procedure call
                    On p. 751 he formulates the 'Command-Query separation principle' as "Functions should not produce
                    abstract side effects"

                    MB: aan de ene kant spreekt dit me wel aan vanwege de Command-Query separation, en dat queries geen
                    side effects zouden mogen hebben
                    aan de andere kant is de volgende slide de meest gebruikte moderne oplossing
                </aside>
            </section>

            <section>
                <h3>A more modern attempt</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def remainingCandies = candies.size
  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    Here the change is that the turn-method return the Candy that falls from the dispenser immediately.
                    The 'command' changes the state and returns information (the dispensed candy)
                </aside>
            </section>


            <section>
                <h3>Taking it for a spin</h3>
                <!-- TODO waar is mutcandies? -->
                <pre><code class="scala" data-trim data-noescape>
val machine = new Machine(mutCandies, 0)

machine.insertCoin(Coin)
val candy: Candy = machine.turn()

candy shouldBe Candy("Blue")
machine.coins shouldBe 1
machine.remainingCandies shouldBe 7
                </code></pre>
                <aside class="notes">
                    mutCandies is a mutable list of candies.
                </aside>
            </section>

        </section>


        <section>
            <section>
                <h2>Problems with the traditional approach</h2>
                <aside class="notes">
                    it has served us well, but in modern times there are some problems and an alternative.
                </aside>
            </section>

            <section>
                <h3>Sharing is no fun</h3>
                <aside class="notes">
                    benoemen problemen rond concurrency met shared mutable state,
                    iets wat in de tijd van het boeknminder speelde. telefoons quad-core.
                </aside>
            </section>

            <section data-background-image="/img/ache-1297598.svg">
                <h3>It makes your head hurt !!</h3>
                <aside class="notes">Note: With a nice picture of course
                    But, WTF is the problem with the mutable state. It looks completely logical and sound to me.
                    That is, because we are used to the object-oriented way of modelling and looking at things.
                    And no, it is not bad, but there are alternatives that can make easier.
                    So why does it makes your head hurt?
                    From https://pixabay.com/nl/ache-hoofd-menselijke-mannelijke-1297598/
                </aside>
            </section>

            <section>
                <pre><code class="scala" data-trim data-noescape>
                            def f(x: Int): Int
                                        
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(f(2)) --> 4</span>
                    
                <span class="fragment">f(f(f(2))) --> 5</span>
                </code></pre>

                <aside class="notes">
                    suppose I have a function like this (only the signature)
                    just a very function with an easy signature that takes an Int and returns an Int

                    and I invoke it like below and get as a return 3, and I do the same thing again .... 3

                    what do I expect if I invoke it like twice: 4
                    and of course reading Uncle Bob's clean code I would shout why not call the function addOne
                    but we have our functional mindset now, so we keep the f.
                    And yes the next function we will call g ;-)

                    and we would go on f(f(f(2)))
                    we can reason about it easily.
                </aside>
            </section>
            <section>
                <h3>Try calling this function more than once...</h3>
                <pre><code class="scala" data-noescape>
var y = 1

def f(x: Int): Int = {
    y = y + x
    y
}               <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 5</span>
                    
                <span class="fragment">f(f(2)) -->14</span>
                    
                <span class="fragment">f(f(f(2))) --> 64</span>
                </code></pre>
                <aside class="notes">
                    This is confusing. The changing of global state is a side-effect which makes it a lot harder to
                    reason about this piece of code. And to calculate the right value you have to know the history of
                    changes.
                    And it doesn't always have to be variables that are global, this also occurs when the scope of the
                    variable is greater than the function it is used in.
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h2>Taking a more functional approach</h2>
                <aside class="notes">
                    Note: door hardware ontwikkelingen is FP sinds een aantal jaren een haalbare kaart.
                    Een van de belangrijkste pillars of FP is referential transparency.
                </aside>
            </section>

            <section>
                <h3>Referential transparency</h3>
                <blockquote>
                    An expression is said to be <br/>
                    referentially transparent<br/>
                    if it can be <strong>replaced</strong><br/>
                    with its corresponding value<br/>
                    <strong>without changing</strong> the program's behavior
                </blockquote>

                <aside class="notes">
                    Calling a function with the same arguments will return the same result every time.

                    This means that you have no assignments that change the global change.
                    This is why immutability is so important.

                    But it also has more impact. For example on exceptions (try/catch semantics).
                </aside>
            </section>
            <section>
                <h3>Benefits of Referential Transparency</h3>

                <ul>
                    <li>Easier to reason about</li>
                    <li>Testable</li>
                    <li>Composable</li>
                    <li>Parallellizable</li>
                </ul>
                <aside class="notes">
                    Note: * Modular why? What are the benefits?
                    Looking at the red book (p. 79), they argue that
                    the lack of referential transparency implies that the code is not as testable, composable, modular
                    and easily parallelized as it could be.
                </aside>
            </section>

        </section>

        <section>
            <section>
                <h2>Introducing immutability</h2>
                <aside class="notes">
                    Note: catchy title ;-)
                </aside>
            </section>

            <section>
                <h3>Remember?</h3>
                <pre><code class="scala" data-noescape>            
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def remainingCandies = candies.size
  def coins = _coins
}
            </code></pre>
            </section>

            <section>
                <h3>Copy on write</h3>
                <pre><code class="scala" data-noescape>
case class Machine(candies: List[Candy], coins: Int)

  
object Machine {
  
  def turn(m: Machine): (Machine, Candy) = 
    (m.copy(candies = m.candies.tail), m.candies.head)

  def insertCoin(coin: Coin, m: Machine): (Machine) =
    m.copy(coins = m.coins + 1)
}
            </code></pre>
                <aside class="notes">
                    We have to introduce companion object and case class (with copy, public val attributes) here.
                    Best explained for Java people as an object to hold your static methods.
                    We need the methods out of Machine case class to prepare for type signature of State Monad.
                </aside>
            </section>

            <section>
                <h3>Immutable drive</h3>
                <pre><code class="scala" data-noescape>        
val m0 = Machine(candies, 0)

val m1:Machine   = Machine.insertCoin(Coin, m0)
val (m2, candy0) = Machine.turn(m1)

val m3           = Machine.insertCoin(Coin, m2)
val (m4, candy1) = Machine.turn(m1)

m4.candies.size shouldBe 6
            </code></pre>
                <aside class="notes">
                    Everything is now immutable, but wiring the state through all the function calls is tedious.
                    And error prone: Do you spot the bug?
                </aside>
            </section>

            <section>
                <h3>Pros</h3>
                <ul>
                    <li>Simple</li>
                    <li>Immutable</li>
                </ul>

                <br/>
                <h3>Cons</h3>
                <ul>
                    <li>Error prone</li>
                </ul>
                <aside class="notes">
                    Note: manual wiring of state through all the calls is error-prone
                </aside>
            </section>
        </section>

        <section>
            <section>
                <h2>Functional State</h2>
                <aside class="notes">
                    Volgorde:
                    - turn method signature
                    - Machine => Machine, Int
                    - S => S,A
                    - Wrap it in a class and refactor.
                    - insertCoin naar analogie van turn veranderen met 2 parameter lijsten (currying)
                    - er mist iets, eigenlijk welk maar in dit geval is a Unit.
                </aside>
            </section>


            <section>
                <h3>Let's look at the type signature</h3>

                <pre><code class="scala" data-noescape>
                    def turn(m: Machine): (Machine, Candy)
                </code></pre>
            </section>

            <section>
                <h3>Machine => (Machine, Candy)</h3>
            </section>

            <section>
                <h3>S => (S<span class="fragment">'</span>, A)</h3>
                <aside class="notes">
                    Or more abstract, we got a function that takes something that represents the State with an output
                    of a tuple of a new State and a value.
                    This is going to be are basic abstract, a function from a State to a new State and a value.
                </aside>
            </section>

            <section>
                <h3>Let's wrap this in a class</h3>

                <pre><code class="scala" data-noescape>      
            class State[S, +A](f: S => (S, A)) {
                    
              def run(initial: S): (S, A) = f(initial)
                    
            }
            </code></pre>
                <aside class="notes">
                    So we have a class State with two Type parameters S and A for the State and the value.
                    The constructor of the class does not take a regular value, but it takes that function
                    from a State to a new State and value.

                    Creating the State does not do anything useful yet.
                    Run will just apply that function and thus return a tuple of a new state and a value.

                    Without combinators the class does not do much of course.
                    We need the class because unlike JavaScript we cannot add methods to functions.
                </aside>
            </section>

            <section>
                <h3>Refactor the current turn method</h3>
                <pre><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
  def turn(): State[Machine, Candy] =
   <span class="fragment fade-out">new </span>State(m => (m.copy(candies = m.candies.tail), m.candies.head) )
<span class="fragment">
// Go, go, go ...
val m0 = Machine(0, candies)

val t: State[Machine, Candy] = Machine.turn()
val (m1, candy) = t run m0

candy shouldBe Candy("Blue")
</span>
                    
                    </code></pre>
                <aside class="notes">
                    If we add an apply function we can even remove the 'new'
                    And again, calling Machine.turn() does not do anything. It just defines a function that will
                    do something WHEN it is applied with a machine.
                    This is shown below, when the run method is called with a machine, then the result is calculated.
                </aside>
            </section>

            <section>
                <h3>Ok, but what about inserting a Coin?</h3>
                <pre><code class="scala" data-noescape>
object Machine {
  def insertCoin(coin: Coin<span class="fragment" data-fragment-index="2">)</span><span class="fragment fade-out"
                                                                                        data-fragment-index="2">,</span><span
                        class="fragment" data-fragment-index="2">(</span>m: Machine): <span class="fragment"
                                                                                            data-fragment-index="1">(</span>Machine<span
                        class="fragment" data-fragment-index="1">, Unit)</span> = 
                 </code></pre>
                <aside class="notes">
                    This does not look like a function S => (S,A),
                    but looking at it more abstractly: the return value from insertCoin is nothing or Unit.
                    And if we are going to use currying of the parameters, we get two parameter lists, with one
                    that is equal to the State datatype we created.
                    So, here we can also refactor it to use the State data type we created.
                </aside>
            </section>

            <section>
                <h3>Doing the mechanical refactoring</h3>
                <pre><code class="scala" data-noescape>
object Machine {
  def insertCoin(coin: Coin): State[Machine, Unit] =
    State(m => (m.copy(coins = m.coins + 1), ()))
                 </code></pre>
                <aside class="notes">
                    So inserting a coin returns basically a datatype holding a function that will take a machine as a
                    parameter
                    and return a new machine with increased number of coins and no concrete value to return.
                </aside>
            </section>
        </section>


        <section>
            <section>
                <h2>Combinators</h2>
                <blockquote>"A combinator is a higher-order function <br/>
                    that uses only function application and<br/>
                    earlier defined combinators<br/>
                    to define a result from its arguments."
                </blockquote>
                <aside class="notes">
                    Note: from https://en.wikipedia.org/wiki/Combinatory_logic
                </aside>
            </section>

            <section>
                <h3>map</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def map[B](transform: A => B): State[S, B] <span class="fragment" data-fragment-index="2">=
    new State[S, B](s0 => {
      val (s1, a) = run(s0)
      (s1, transform(a))
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----                    
         |   | -----------------------> s1 
   s0 -> | f |         -------------         
         |   | -> a -> | transform | ->  b
         -----         -------------         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now it's getting interesting. What if we want to combine and transform the value.
                    What if we, when running the state function would like to transform the resulting value.
                    Just like with a List we can do that with the map function.
                    How does it look like graphically? We have a machine that we give to the run-function of the State
                    (which basically applies f to s0).
                    The run function delivers a new State (machine) and a value 'a'. The value a is transformed by the
                    map-function to a b.
                </aside>
            </section>
            <section>
                <h3>Spin it</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val turn   : State[Machine, Candy] = Machine.turn()
val program: State[Machine, String] = turn.map(_.color)
val (m1, color) = program.run(m0)

color shouldBe "Blue"
                </code></pre>
                <aside class="notes">
                    So we have now a new function that combines the turn function with a function that transforms the
                    resulting output.
                    And we can write this more succintly as the Scala compiler can infers most types.
                </aside>
            </section>

            <section>
                <h3>Or more ideomatic</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = Machine.turn().map(_.color)
val (m1, color) = program.run(m0)
      
color shouldBe "Blue"
                </code></pre>
            </section>

            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def flatMap[B](g: A => State[S, B]): State[S, B] <span class="fragment" data-fragment-index="2">=
    State(s0 => {
      val (s1, a) = run(s0)
      g(a).run(s1)
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----           -----         
         |   | ->  s1 -> |   | -> s2 
   s0 -> | f |           | g |         
         |   | ->   a -> |   | -> b
         -----           -----         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now looking at flatMap.
                    So the state function takes a state (think machine) and the resulting output of running is a
                    modified state and an a.
                    The function g takes an a and returns a State[S,B]. But a State is just a function from S => (S,A).
                    So in the end we first have to feed the function g an 'a', so we get a new State function.
                    And then 'run' the State function by providing the new State 's' that was the result of running the
                    f-function.
                    This gives us the return value: a tuple of (S,B).

                    Implementing this now, is a piece of cake (a big piece, that is ;-))
                </aside>
            </section>
            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = Machine.insertCoin(Coin)
                     .flatMap(_ => Machine.turn())
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Blue")
                </code></pre>
                <aside class="notes">
                    We have been lying until now, the domain prescribes that we insert a coin first.
                    Remember we get a State[Machine, Unit) as a result. And then we want to turn the machine.
                    As we are not interested in the resulting value of insertCoin (Unit) we disregard the parameter.
                    The State (or the Machine) will be used in the flatMap function.
                    In the end the resulting return type of turn is the State[Machine,Candy], so we the last validation
                    is successfull.
                </aside>
            </section>
            <section>
                <h3>This is getting cumbersome</h3>
                <pre><code class="scala" data-noescape>
val program =
  Machine.insertCoin(Coin)
    .flatMap(_ => Machine.turn()
      .flatMap(_ => Machine.insertCoin(Coin)
        .flatMap(_ => Machine.turn())))
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                </aside>
            </section>


            <section>
                <h3>Using for comprehensions</h3>
                <pre><code class="scala" data-noescape>
val program = for {
  _ <- insertCoin(Coin)
  _ <- turn()
  _ <- insertCoin(Coin)
  candy <- turn()
} yield candy

val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                    For those familiar with Scala know that flatMaps can be elegantly replaced with a for-comprehension.
                </aside>
            </section>
            <section>
                <h3>FP with Getters and Setters</h3>
                <aside class="notes">
                    That for code already looks more imperative. But can we make it even more imperative?
                    Yes! Welcome our old friends getter and setter!
                </aside>
            </section>
            <section>
                <h3>Now what if we just want to get the state?</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def get[S]: State[S, S] = new State(s => (s, s))
  ...
}
                </code></pre>      
            </section>
            <section>
                <h3>And with get comes set</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def set[S](newS: S): State[S, Unit] = new State(_ => (newS, ()))
  ...
}
                </code></pre>      
            </section>
            <section>
                <h3>Doing the refactoring</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] =
    State(m => (m.copy(coins = m.coins + 1), ()))
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  m <- State.get[Machine]
  _ <- State.set(m.copy(coins = m.coins + 1))
} yield ()
                </code></pre>
            </section>

            <section>
                <h3>Get and Set == Modify</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def modify[S](f: S => S): State[S, Unit] = new State(s => (f(s), ()))
  ...
}
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  u <- State.modify[Machine](m => m.copy(coins = m.coins + 1))
} yield u
                </code></pre>
            </section>

        </section>

        <section>
            <h3>References</h3>
            <ul>
                <li><a href="https://github.com/aggenebbisj/functionalstate">Presentation</a> </li>
                <li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in
                    Scala</a></li>
                <li><a href="https://www.youtube.com/watch?v=Jg3Uv_YWJqI)">Michael Pilquist - Scalaz State Monad</a>
                </li>
                <li><a href="https://www.youtube.com/watch?v=XxzzJiXHOJs](https://www.youtube.com/watch?v=XxzzJiXHOJs">Brian
                    Beckman: The Zen of Stateless State - The State Monad</a></li>
                
            </ul>
        </section>

        <section data-markdown="presentation.md"
                 data-separator="^---"
                 data-separator-vertical="^\n\n"
                 data-separator-notes="^Note:"
                 data-charset="UTF8"
                 data-state="mybackground"
                 data-background-image="img/stars.svg"
                 data-background-position="top left"
                 data-background-size="800px">
        </section>


        <section data-background-image="img/the_coming_curse_by_mistabobby1.jpg">
            <h2>Monadic Curse</h2>
            <blockquote>
                once someone learns what monads are
                and how to use them, <br/>
                they loose the ability <br/>
                to explain it to other people.

            </blockquote>
            <a href="https://www.youtube.com/watch?v=b0EF0VTs9Dc">Douglas Crockford</a>
            <aside class="notes">
                [Monads and Gonads - Douglas Crockford](https://www.youtube.com/watch?v=b0EF0VTs9Dc)
                image from
                https://contemporaryshaman.files.wordpress.com/2013/11/the_coming_curse_by_mistabobby1.jpg
            </aside>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
