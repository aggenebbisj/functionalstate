<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom stylesheet -->
    <link rel="stylesheet" href="css/my.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Never change state</h1>
            <h2>and still get things done</h2>
            <br/>
            <br/>
            <table>
                <thead>
                <tr>
                    <th>Remko de Jong</th>
                    <th>Martijn Blankestijn</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>
                        <a href="https://www.siteworkers.nl/">
                            <div class="logo">
                                <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg"  height="6em" x="0px" y="0px" viewBox="0 0 55.1 125.6" enable-background="new 0 0 55.1 125.6" xml:space="preserve"><g><path d="M3.2,69l52-15.1L29,0l0,0l0,0l0,0l0,0C28.6,0.4,0.4,34,0.2,34.2L0,34.4l2.7,34.7l0,0l0,0l0,0L3.2,69zM1,34.7c0.7-0.8,4.4-5.2,26.9-31.9L3.5,66.9L1,34.7z"></path><g><path d="M5.7,87.6c0-1.3,0.8-1.9,2.3-1.9c0.5,0,1.2,0.1,1.9,0.4L9.6,87c-0.7-0.2-1.3-0.3-1.7-0.3c-0.4,0-0.7,0.1-0.9,0.2c-0.2,0.1-0.3,0.4-0.3,0.7c0,0.2,0.1,0.4,0.3,0.6c0.2,0.2,0.5,0.3,1,0.4c0.7,0.2,1.2,0.4,1.5,0.7c0.3,0.3,0.4,0.8,0.4,1.4c0,1.3-0.8,2-2.4,2c-0.5,0-1.2-0.1-2-0.3l0.2-1c0,0,0.1,0,0.3,0.1c0.7,0.2,1.2,0.3,1.6,0.3c0.4,0,0.6-0.1,0.8-0.3c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.2-0.7c-0.2-0.2-0.4-0.3-0.9-0.4c-0.7-0.2-1.3-0.5-1.6-0.8C5.9,88.6,5.7,88.1,5.7,87.6z"></path><path d="M17.6,92.6v-1h1.3v-4.9h-1.3v-1h3.7v1H20v4.9h1.2v1H17.6z"></path><path d="M28.6,86.7v-1h4.6v1h-1.8v5.8h-1.1v-5.8H28.6z"></path><path d="M40.5,92.6v-6.8h4v1h-2.9v1.9h2.6v0.9h-2.6v2h2.9v1H40.5z"></path><path d="M5.9,109l-0.6-6.8h1l0.5,5.9h0.1l0.6-3h0.9l0.6,3h0.1l0.4-5.9h1L10,109H8.4l-0.5-2.7h0L7.4,109H5.9z"></path><path d="M19.4,109.1c-0.8,0-1.4-0.3-1.8-0.9c-0.4-0.6-0.5-1.5-0.5-2.7c0-1.2,0.2-2.1,0.6-2.6c0.4-0.6,1-0.8,1.8-0.8c0.8,0,1.4,0.3,1.8,0.8c0.4,0.5,0.5,1.4,0.5,2.7c0,1.2-0.2,2.1-0.5,2.7C20.9,108.9,20.3,109.1,19.4,109.1z M19.4,108.2c0.5,0,0.8-0.2,1-0.5c0.2-0.4,0.3-1,0.3-2c0-1-0.1-1.7-0.3-2c-0.2-0.3-0.5-0.5-1-0.5s-0.8,0.2-1,0.5c-0.2,0.4-0.3,1-0.3,1.9c0,0.9,0.1,1.6,0.2,2C18.6,108,18.9,108.2,19.4,108.2z"></path><path d="M30.9,106.6c-0.4,0-0.6,0-0.6,0h-0.5v2.5h-1.1v-6.8h2.1c0.8,0,1.3,0.2,1.7,0.5c0.4,0.3,0.6,0.9,0.6,1.7c0,0.9-0.4,1.5-1.2,1.9c0.5,0.9,0.9,1.8,1.2,2.7h-1.2C31.7,108.2,31.4,107.4,30.9,106.6z M30.7,103.2h-0.9v2.4h0.9c0.9,0,1.4-0.4,1.4-1.2c0-0.4-0.1-0.8-0.3-0.9C31.5,103.3,31.2,103.2,30.7,103.2z"></path><path d="M40.5,109v-6.8h1.1v3l0.6-0.1c0.4-0.7,0.9-1.5,1.4-2.4l0.2-0.5h1.2c-0.7,1.4-1.3,2.5-1.9,3.3c0.2,0.3,0.5,0.8,0.8,1.4L45,109h-1.2c-0.7-1.4-1.2-2.3-1.6-2.9l-0.6,0.1v2.9H40.5z"></path><path d="M5.9,125.5v-6.8h4v1H7v1.9h2.6v0.9H7v2h2.9v1H5.9z"></path><path d="M19.4,123c-0.4,0-0.6,0-0.6,0h-0.5v2.5h-1.1v-6.8h2.1c0.8,0,1.3,0.2,1.7,0.5c0.4,0.3,0.6,0.9,0.6,1.7c0,0.9-0.4,1.5-1.2,1.9c0.5,0.9,0.9,1.8,1.2,2.7h-1.2C20.2,124.7,19.8,123.8,19.4,123z M19.1,119.7h-0.9v2.4h0.9c0.9,0,1.4-0.4,1.4-1.2c0-0.4-0.1-0.8-0.3-0.9C20,119.8,19.6,119.7,19.1,119.7z"></path><path d="M28.8,120.5c0-1.3,0.8-1.9,2.3-1.9c0.5,0,1.2,0.1,1.9,0.4l-0.2,0.9c-0.7-0.2-1.3-0.3-1.7-0.3c-0.4,0-0.7,0.1-0.9,0.2c-0.2,0.1-0.3,0.4-0.3,0.7c0,0.2,0.1,0.4,0.3,0.6c0.2,0.2,0.5,0.3,1,0.4c0.7,0.2,1.2,0.4,1.5,0.7s0.4,0.8,0.4,1.4c0,1.3-0.8,2-2.4,2c-0.5,0-1.2-0.1-2-0.3l0.2-1c0,0,0.1,0,0.3,0.1c0.7,0.2,1.2,0.3,1.6,0.3c0.4,0,0.6-0.1,0.8-0.3c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.2-0.7c-0.2-0.2-0.4-0.3-0.9-0.4c-0.7-0.2-1.3-0.5-1.6-0.8C29,121.5,28.8,121.1,28.8,120.5z"></path></g></g></svg>
                            </div>
                        </a>
                    </td>
                    <td><a href="http://www.codestar.nl"><img src="img/logo-simple.svg"
                                                              style="border: none; background-color: transparent; vertical-align: middle"
                                                              height="75em"/>
                    </a>
                    </td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
                <ul>
                    <li>Examples in Scala</li>
                    <li>Experience with function state in a real-life project, implementation and simulation of the
                        order of flyers
                    </li>
                    <li>Preferably questions at the end</li>
                </ul>
                <strong>Abstract from JFall site</strong>
                <p>
                    State can be difficult. Concurrent updates can lead to inconsistency, it can be difficult to scale
                    and have you ever tried testing a component with a random element without having to resort to
                    mocking?
                    Functional purity can help us here.
                </p>
                <p>
                    In this talk, we are going to investigate how we can design a pure functional structure that
                    abstracts over state manipulations. We will start with a solution that uses mutable state to solve a
                    problem.
                    Then we will refactor step by step and eventually transform it to pure functional code that never
                    changes state.
                </p>
                <p>
                    Familiarity with lambdas is assumed, but no knowledge of functional programming is required.
                    Code examples are in Scala, but no advanced language concepts are used, so knowledge of Java 8 is
                    sufficient.
                </p>
                <p>
                    As an audience, I would get a comparative overview of solving a problem in a traditional way with
                    imperative code and with pure functional structures.
                    I would also learn the benefits of purely functional state and its drawbacks.
                </p>
                <p>
                    Time schedule
                    # Minuten Totaal
                    Presentatie onderdelen 0
                    Intro / Agenda 2 2
                    Domain / Traditional approach + nadelen M 10 12
                    More functional approach / pros/cons S 6 18
                    Functional staTe M 8 26
                    Combinators S 12 38
                    FP with Getters and Setters M/S 5 43
                    Pro / Cons summary 2 45
                </p>
            </aside>
        </section>

        <section>

            <section data-background-image="/img/why.jpg"
                     data-background-size="auto 100%"
                     data-background-color="#ffffff">
                <aside class="notes">
                    <ul>
                        <li>Why this talk?</li>
                        <li>Transitioning to FP, looking for new solutions</li>
                        <li>Use case in real project</li>
                        <li>Single machine planning</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h2>Roadmap</h2>

                <ol>
                    <li>Traditional OO approach</li>
                    <li>Transitioning from mutable to immutable</li>
                    <li>Immutable with State data structure</li>
                </ol>
            </section>

            <section data-background-image="/img/scala-logo.png"
                     data-background-size="auto 100%">
                <!-- <h2>WARNING: Scala ahead</h2> -->
                <aside class="notes">
                    <ul>
                        <li>Code samples in Scala</li>
                        <li>No advanced language constructs used however</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h2>Crash course Scala</h2>
            </section>

            <section>
                <pre>
                        <table style="width: 100%">
                    <thead>
                    <tr>
                        <th>Java</th>
                        <th>Scala</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <code class="Java">int foo;</code>
                        </td>
                        <td>
                            <code class="fragment scala">var foo: Int</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code class="Java">final int foo;</code>
                        </td>
                        <td>
                            <code class="fragment scala">val foo: Int</code>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <code class="Java">asList(1, 2, 3).stream()
    .map(x -> x + 1)
    .collect(Collectors.toList());
                        </code>
                        </td>
                        <td>
                            <code class="fragment scala">List(1, 2, 3).map(x => x + 1)</code>
                        </td>
                    </tr>
                    </tbody>
                    </table>
                </pre>
            </section>


            <section>
                <pre>
<code class="scala">// Scala
case class Foo(x: Int)

case object Foo {
    def apply(): Foo = new Foo()
}</code>    
<code class="Java">// Java
class Foo {
    final int x;

    public Foo(int x) {
        this.x = x;
    }

    public int getX() { return x; }

    // and some additional methods like equals, copy, ...
}</code>
                </pre>
            </section>

        </section>

        <section>
            <section>
                <h2 class="martijn">The domain</h2>
            </section>

            <section data-background-image="/img/candydispenser.jpg"
                     data-background-size="auto 100%"
                     data-background-color="#ffffff">
                <aside class="notes">
                    <p>A vending machine from which you can buy candies.</p>
                    <p>
                        The vending machine can process two types of inputs from customers. A customer can
                    </p>
                    <ol>
                        <li>insert money</li>
                        <li>turn the knob to get the candy</li>
                    </ol>
                </aside>
            </section>

            <section>
                <h3><code class="scala">The code</code></h3>
                <pre><code class="scala" data-trim data-noescape>
case class Coin()

case class Candy(color: Color)
                    </code></pre>
                <aside class="notes">
                    <ul>
                        <li>case class: members are val, copy</li>
                        <li>Color is like a Java enumeration</li>
                        <li>Remember the order of the colors</li>
                    </ul>
                    <p>We have a simple economy with just one type of coin, just like a festival.</p>
                </aside>
            </section>
        </section>

        <!-- Traditional OO Approach -->
        <section>
            <section>
                <h2>The traditional OO approach</h2>
                <img src="/img/object-oriented-software-construction.jpg"/>
                <aside class="notes">
                    <p>Who knows this classic writing? Betrand Meyer (1: 1988, 2: 1997)</p>
                    <p>one of the earliest and most vocal proponents of object-oriented programming (OOP)</p>
                    <p>Command-Query separation principle: Features of a class are</p>
                    <ul>
                        <li><strong>Commands</strong> modify objects, but do <em>not</em> return results</li>
                        <li><strong>Queries</strong> return information about object and should not produce a side
                            effect
                        </li>
                    </ul>
                    
                    <ul>
                        <li>First edition written in 1988 by Bertrand Meyer</li>
                        <li>Second edition appeared in 1997 at a whopping 1200 pages</li>
                    </ul>
                    <p>
                    <p>
                        Meyer p. 748 "The features that characterize a class are divided into commands and queries.
                        A command serves to modify objects, a query to return information about objects."
                        p. 749 A function (defined as routine that returns a result) produces a concrete side effect if
                        its body contains any of the following
                        * an assignment, assignment attempt or creation instruction whose target is an attribute * a
                        procedure call
                        On p. 751 he formulates the 'Command-Query separation principle' as "Functions should not
                        produce abstract side effects"
                    </p>

                    <p>
                        "Meyer pursues the ideal of simple, elegant and user-friendly computer languages and
                        is one of the earliest and most vocal proponents of object-oriented programming (OOP).
                        His book Object-Oriented Software Construction is widely considered to be the best work on
                        presenting the case for OOP."
                        https://en.wikipedia.org/wiki/Bertrand_Meyer</p>
                </aside>
            </section>
            <!--            
                        <section>
                            <h3>A first attempt: Command/Query Separation</h3>
                            <pre><code class="scala" data-trim data-noescape>
            class Machine(private val candies: ListBuffer[Candy],
                          private var _coins: Int) {
              private var _lastCandy: Candy = _
            
              // 'Commands' modify machine
              def insertCoin(coin: Coin): Unit = _coins = _coins + 1
              def turn(): Unit = { _lastCandy = candies.remove(0) }
            
              // 'Queries' return information about machine
              def lastCandy = _lastCandy
              def coins = _coins
            }
                            </code></pre>
                            <aside class="notes">
                                <ul>
                                    <li>A ListBuffer is a mutable data structure.</li>
                                    <li>Due to command-query separation turn only changes the list of candies and the last candy
                                        that was returned.
                                    </li>
                                    <li>The _(underscore) is necessary to keep the mutable state private.</li>
                                </ul>
                                <p>
                                    MB: aan de ene kant spreekt dit me wel aan vanwege de Command-Query separation, en dat queries
                                    geen
                                    side effects zouden mogen hebben
                                    aan de andere kant is de volgende slide de meest gebruikte moderne oplossing
                                </p>
                            </aside>
                        </section>
            -->
            <section>
                <h3>A first attempt</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: mutable.Buffer[Candy],
              private var coins: Int) {
  
  def insertCoin(coin: Coin): Unit = coins = coins + 1
  
  def turn(): Candy = candies.remove(0)

                    
  def getCoins = coins
}
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>2 class parameters -> primary constructor</li>
                        <li>Buffer: mutable collection</li>
                        <li>Public is Scalaâ€™s default access level.</li>
                        <li>def = function definition name, parameter list and return type</li>
                        <li>absence of parenthesis, accessor without side-effects</li>
                    </ul>
                    <p>
                        2 class parameters -> Scala Compiler will create primary constructor
                        Here the change is that the turn-method return the Candy that falls from the dispenser
                        immediately.
                        The 'command' changes the state and returns information (the dispensed candy)
                    </p>
                    <p>
                        "Methods which act as accessors of any sort (either encapsulating a field or a logical property)
                        should be declared without parentheses except if they have side effects."
                        http://docs.scala-lang.org/style/naming-conventions.html#parentheses
                    </p>
                </aside>
            </section>


            <section>
                <h3>Taking it for a spin</h3>
                <pre><code class="scala" data-trim data-noescape>
val candies = ArrayBuffer(Candy(BLUE), 
                          Candy(RED), 
                          Candy(GREEN))

val machine = new Machine(candies, 0)

<span class="fragment">machine.insertCoin(Coin())
val candy: Candy = machine.turn()
</span>
<span class="fragment">candy shouldBe Candy(BLUE)
machine.getCoins shouldBe 1
</span>
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>scala ArrayBuffer is like an ArrayList.</li>
                        <li>Remember the order! We will use it later</li>
                    </ul>
                    
                    <code>candies</code> is a mutable list of candies.
                </aside>
            </section>

        </section>
        <!-- EOF Traditional OO Approach -->

        <!-- Problems with traditional approach -->
        <section>
            <section>
                <h2>Problems with the traditional approach</h2>
                <aside class="notes">
                    It has served us well, but in modern times there are some problems and an alternative.
                    "Functional programming was invented in 1957, before structured programming, before object oriented
                    programming.
                    But memory was too expensive to make it practical."
                </aside>
            </section>

            <section>
                <h3>Sharing is no fun</h3>
                <aside class="notes">
                    <ul>
                        <li>Learnt that in kindergarten</li>
                        <li>Concurrency and shared mutable state don't play nicely together</li>
                        <li>Less of a problem back in the days. Now we have quad-core phones</li>
                    </ul>
                </aside>
            </section>

            <section data-background-image="/img/ache-1297598.svg">
                <h3>It makes your head hurt !!</h3>
                <aside class="notes">
                    But, WTF is the problem with the mutable state. It looks completely logical and sound to me.
                    That is, because we are used to the object-oriented way of modelling and looking at things.
                    And no, it is not bad, but there are alternatives that can make easier.
                    So why does it makes your head hurt?
                    From https://pixabay.com/nl/ache-hoofd-menselijke-mannelijke-1297598/
                </aside>
            </section>

            <section>
                <h3>Consider something simple</h3>
                <pre><code class="scala" data-trim data-noescape>
                            def f(x: Int): Int <span class="fragment" data-fragment-index="4">= x + 1</span>
                                        
                <span class="fragment" data-fragment-index="1">f(2) --> 3</span>
                    
                <span class="fragment" data-fragment-index="2">f(2) --> 3</span>
                    
                <span class="fragment"  data-fragment-index="3">f(f(2)) --> 4</span>
                    
                <span class="fragment">f(f(f(2))) --> 5</span>
                </code></pre>

                <aside class="notes">
                    suppose I have a function like this (only the signature)
                    just a very function with an easy signature that takes an Int and returns an Int

                    and I invoke it like below and get as a return 3, and I do the same thing again .... 3

                    what do I expect if I invoke it like twice: 4
                    and of course reading Uncle Bob's clean code I would shout why not call the function addOne
                    but we have our functional mindset now, so we keep the f.
                    And yes the next function we will call g ;-)

                    and we would go on f(f(f(2)))
                    we can reason about it easily.
                </aside>
            </section>
            <section>
                <h3>Now try calling this function more than once...</h3>
                <pre><code class="scala" data-noescape>
var y = 1

def f(x: Int): Int = {
    y = x + y
    y
}               
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 5</span>
                    
                <span class="fragment">f(f(2)) --> 14</span>
                    
                <span class="fragment">f(f(f(2))) --> 64</span>
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>confusing: side-effect</li>
                        <li>how can we overcome these problems?</li>
                    </ul>
                    <p>This is confusing. The changing of state with a wider scope than the function is a side-effect
                        which makes it a lot harder to reason about this piece of code.
                        And to calculate the right value you have to know the history of changes.</p>
                    <p>And it doesn't always have to be variables that are global, this also occurs when the scope of
                        the variable is greater than the function it is used in.</p>
                </aside>
            </section>
        </section>
        <!-- EOF Problems with traditional approach -->

        <!-- A more functional approach -->
        <section>
            <section data-background-image="img/fp.png"
                     data-background-size="auto 100%">
                <h2 class="remko">Taking a more functional approach</h2>
                <aside class="notes">
                    <ul>
                        <li>Hardware improvements make FP feasible nowadays. This was different back in the 70's.</li>
                        <li>One of the pillars of FP is referential transparency.</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h3>Referential transparency</h3>
                <blockquote>
                    An expression is said to be <br/>
                    referentially transparent<br/>
                    if it can be <strong>replaced</strong><br/>
                    with its corresponding value<br/>
                    <strong>without changing</strong> the program's behavior
                </blockquote>

                <aside class="notes">
                    <ul>
                        <li>Pure functions</li>
                        <li>Calling a function with same arguments always returns same result</li>
                        <li>No side effects</li>
                        <li>No assignments that change the global change. Hence immutability</li>
                        <li>Also impacts try / catch semantics</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h3>Benefits of Referential Transparency</h3>

                <ul>
                    <li>Easier to reason about</li>
                    <li>Testable</li>
                    <li>Composable</li>
                    <li>Parallellizable</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Reason: you can replace stuff and use induction</li>
                        <li>Test: you can do blackbox testing: data in, data out</li>
                        <li>Composable: functions play nice, just align the types</li>
                        <li>Parallellizable: no shared mutable state</li>
                    </ul>
                    Note: * Modular why? What are the benefits?
                    Looking at the red book (p. 79), they argue that
                    the lack of referential transparency implies that the code is not as testable, composable, modular
                    and easily parallelized as it could be.
                </aside>
            </section>

        </section>
        <!-- EOF A more functional approach -->

        <!-- Introducing immutability -->
        <section>
            <section>
                <h2>So stop trying to change me</h2>
                <aside class="notes">
                    <ul>
                        <li>Let's look at an attempt without changing state</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h3>Remember?</h3>
                <pre><code class="scala" data-noescape>            
class Machine(private val candies: mutable.Buffer[Candy],
              private var coins: Int) {
  
  def insertCoin(coin: Coin): Unit = coins = coins + 1
  
  def turn(): Candy = candies.remove(0)

                    
  def getCoins = coins
}
            </code></pre>
            </section>

            <section>
                <h3>Recipe for immutability</h3>
                <pre><code class="scala" data-noescape>
case class Machine(candies: immutable.List[Candy], coins: Int)

  
object Machine {
  
  def turn(m: Machine): (Machine, Candy) = 
    ( m.copy(candies = m.candies.tail), m.candies.head )

  def insertCoin(coin: Coin, m: Machine): Machine =
    m.copy(coins = m.coins + 1)
}
            </code></pre>
                <aside class="notes">
                    <ul>
                        <li>Recipe is we pass state explicitly and make a copy</li>
                    </ul>
                    <ul>
                        <li>a factory method (no new keyword needed)</li>
                        <li>all arguments in the parameter list are implicitly val's, so immutable</li>
                        <li>adds a copy method for making modified copies</li>
                    </ul>

                    <p>The keyword 'object' indicates that something is not a class, but a singleton.
                        If it has the same name as a class in the same file, it is called the <em>companion object</em>,
                        because both can access eachothers private members</p>
                    <p>
                        We need the methods out of Machine case class to prepare for type signature of State Monad.</p>
                    <p>We have now made the state explicit by adding it as an argument and return type to every function
                        call.
                        Tbe state is not longer implicit, hidden within some object that will be updated. It is made
                        explicit</p>
                </aside>
            </section>

            <section>
                <h3>Immutable test drive</h3>
                <pre><code class="scala" data-noescape>        
val candies = List(Candy(BLUE), Candy(RED), Candy(GREEN))

val m0 = Machine(candies, 0)

val m1: Machine  = Machine.insertCoin(Coin(), m0)
val (m2, candy0) = Machine.turn(m1)

val m3           = Machine.insertCoin(Coin(), m2)
val (m4, candy1) = Machine.turn(<span class="fragment highlight-red">m1</span>)

m4.coins shouldBe 2
m4.candies.size shouldBe 1
            </code></pre>
                <aside class="notes">
                    <ul>
                        <li>still looks imperative</li>
                        <li>manual wiring</li>
                        <li>spot the bug?</li>
                    </ul>
                </aside>
            </section>

            <section>
                <h3>Stateless with manual wiring</h3>
                <table>
                    <thead>
                    <tr>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <ul>
                                <li>Simple</li>
                                <li>Immutable</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Extra argument and return value</li>
                                <li>Error prone</li>
                            </ul>
                        </td>
                    </tr>
                    </tbody>
                </table>

                <aside class="notes">
                    So can we do something about the cons?
                    <p>
                        Now we have seen the basic pattern for changing a stateful API to a purely functional API.
                        The key to recovering referential transparency is to make the state updates explicit.
                        So we pass in the old state, return the new state and the value if that exists and leave the old
                        state unchanged.
                    </p>
                    <p>Note: manual, explicit wiring of state through all the calls is error-prone as we have seen</p>
                </aside>
            </section>
        </section>
        <!-- EOF Introducing immutability -->

        <!-- Using a Functional State Data Structure -->
        <section>
            <section>
                <h2 class="martijn">Functional State</h2>
            </section>


            <section>
                <h3>Let's look at the type signature</h3>

                <pre class="important"><code class="scala" data-noescape>
def turn(m: Machine): (Machine, Candy)
                </code></pre>
            </section>

            <section>
                <h3>More abstract</h3>
                
                <pre class="important"><code class="scala">
Machine => (Machine, Candy)
                </code>
                    </pre>
            </section>

            <section>
                <h3>Even more abstract</h3>
                
                <pre class="important"><code class="scala" data-noescape=>
S<span style="color: red" class="fragment" data-fragment-index="1">0</span> =>(S<span style="color: red" class="fragment" data-fragment-index="1">1</span>, A)
                </code>
                </pre>
                <aside class="notes">
                    Or more abstract, we got a function that takes something that represents the State with an output
                    of a tuple of a new State and a value.
                    So we have a function from a State to a new State and a value.
                </aside>
            </section>

            <section>
                <h3>Let's wrap this in a class</h3>

                <pre><code class="scala" data-noescape>      
case class State[S, +A](f: S => (S, A)) {
        
  def run(initial: S): (S, A) = f(initial)
        
}
            </code></pre>
                <aside class="notes">
                    <p>separating function construction and the computation (applying).</p>

                    NB: <code class="scala">new State(f).run(s) == f(s)</code>
                    <p>
                        So we have a class State with two Type parameters S and A for the State and the value.
                        The constructor of the class does not take a regular value, but it takes that function
                        from a State to a new State and value.
                    </p>
                    <p>
                        Creating the State does not do anything useful yet.
                        Run will just apply/invoke that function and thus return a tuple of a new state and a value.
                        We'll get to the more useful part later!
                    </p>
                    <p>
                        Without combinators the class does not do much of course.
                        We need the class because unlike JavaScript we cannot add methods to functions.
                    </p>
                </aside>
            </section>


            <section>
                <h3>Refactor the current turn method</h3>
<pre><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
                    
  def turn(m: Machine): (Machine, Candy) = 
    ( m.copy(candies = m.candies.tail), m.candies.head )
<span class="fragment">      

  def turn(): State[Machine, Candy]</span><span class="fragment"> = State(m =></span> 
<span class="fragment">    ( m.copy(candies = m.candies.tail), m.candies.head )
  )
</span>                </code></pre>
                <aside class="notes">
                    If we add an apply function we can even remove the 'new'
                    And again, calling Machine.turn() does not do anything. It just defines a function that will
                    do something WHEN it is applied with a machine.
                    This is shown below, when the run method is called with a machine, then the result is calculated.
                </aside>
            </section>
            
            <section>
                <h3>Ok, but what about inserting a Coin?</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin<span class="fragment" data-fragment-index="3">)</span><span class="fragment fade-out"
                                                                                      data-fragment-index="3">,</span><span
                        class="fragment" data-fragment-index="3">(</span>m: Machine): <span class="fragment"
                                                                                            data-fragment-index="1">(</span>Machine<span
                        class="fragment" data-fragment-index="1">, Unit) </span>=
    <span class="fragment" data-fragment-index="2">( </span>m.copy(coins = m.coins + 1)<span class="fragment" data-fragment-index="2">, () )</span>


<span class="fragment">def insertCoin(coin: Coin): State[Machine, Unit] </span><span class="fragment">= State(m =></span>
    <span class="fragment">( m.copy(coins = m.coins + 1), () )
  )</span>

                 </code></pre>
                <aside class="notes">
                    <p>This does not look like a function S => (S,A),
                        but looking at it more abstractly: the return value from insertCoin is nothing or Unit.</p>

                    <p>And if we are going to use currying of the parameters, we get two parameter lists, with the last 
                        parameter together with the return value are an exact match of the function of the constructor 
                        of the State datatype.
                        Currying is named after Haskell Brooks Curry , who was an American mathematician and logician.
                        It is the technique of translating the evaluation of a function that takes multiple arguments
                        (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.
                        In this case we change a function that takes two parameters and returns a tuple of Machine and
                        Unit to a function with one parameter (Coin), that returns a function that takes one parameter and
                        returns a tuple of Machine and Unit.
                    <p>So, here we can also refactor it to use the State data type we created.
                    </p>
                </aside>
            </section>



            <section>
                <h3>... and run it</h3>
                <pre><code class="scala" data-noescape>
// describe
val insertCoin: State[Machine, Unit] = Machine.insertCoin()

// execute
val m0 = Machine(0, candies)
val (m1, candy) = insertCoin.run(m0)

candy shouldBe Candy(BLUE)
                </code></pre>
                <aside class="notes">
                    Something fundamentally has changed. Now turn and insertCoin suddenly are lazy.
                </aside>
            </section>

            <section data-background-image="img/camron_u_mad.jpg">
                <h3>Now hold on a minute...</h3>
                <h4>Didn't you just make it more complex?</h4>
                <aside class="notes">
                    Yes we did make it more complex, but...
                    This allows us to use combinators (which allow us to compose functions and rewrite this into
                    something nicer)
                    Background: u mad meme: http://nymag.com/selectall/2015/12/nine-canonical-responses-to-u-mad.html
                </aside>
            </section>
        </section>
        <!-- EOF Using a Functional State Data Structure -->

        <!-- Combinators -->
        <section>
            <section>
                <h2 class="remko">Composing Functions</h2>
            </section>

            <section data-background-image="img/composingfunctions.jpg"
                     data-background-size="auto 100%"
                     class="center">
                <img style="transform: scale(2)" class="fragment" data-src="img/captainplanet.jpeg"/>
            </section>

            <section>
                <pre>
                    <h2>Let's introduce map first</h2>
                    <code class="scala">List(1, 2, 3).map(x => x + 1)</code>
            </section>

            <section>
                <h3>map</h3>
                <pre><code class="scala" data-noescape>
case class State[S, +A](f: S => (S, A)) {
                    
  def map[B](transform: A => B): State[S, B] <span class="fragment" data-fragment-index="2">=
    new State[S, B](</span><span class="fragment" data-fragment-index="3">s0 => {</span>
      <span class="fragment" data-fragment-index="4">val (s1, a) = run(s0)</span>
      <span class="fragment" data-fragment-index="5">(s1, transform(a))</span>
    <span class="fragment" data-fragment-index="3">}</span><span class="fragment" data-fragment-index="2">)</span>
}</span>

<span class="fragment" data-fragment-index="6">
         +---+                    
         |   | -----------------------> s1 
   s0 -> | f |         +-----------+         
         |   | -> a -> | transform | ->  b
         +---+         +-----------+         
</span>

                </code></pre>
                <aside class="notes">
                    Implementation follows from definition.
                    Ok, now it's getting interesting. What if we want to combine and transform the value.
                    What if we, when running the state function would like to transform the resulting value.
                    Just like with a List we can do that with the map function.
                    How does it look like graphically? We have a machine that we give to the run-function of the State
                    (which basically applies f to s0).
                    The run function delivers a new State (machine) and a value 'a'. The value a is transformed by the
                    map-function to a b.
                </aside>
            </section>

            <section>
                <h3>Spin it</h3>
                <pre><code class="scala" data-noescape>
// describe
val turn   : State[Machine, Candy] = Machine.turn()
val program: State[Machine, String] = 
               turn.map(candy => candy.color)

// execute
val m0 = Machine(0, candies)
val (m1, color) = program.run(m0)

color shouldBe BLUE
                </code></pre>
                <aside class="notes">
                    So we have now a new function that combines the turn function with a function that transforms the
                    resulting output.
                    And we can write this more succintly as the Scala compiler can infers most types.
                </aside>
            </section>

            <section>
                <h3>Or more idiomatically</h3>
                <pre><code class="scala" data-noescape>
val program = turn().map(candy => candy.color)

val m0 = Machine(0, candies)
val (m1, color) = program.run(m0)
      
color shouldBe BLUE
                </code></pre>
            </section>

            <section>
                <h3>Combinators</h3>
                <blockquote>"A combinator is a higher-order function <br/>
                    that uses only function application and<br/>
                    earlier defined combinators<br/>
                    to define a result from its arguments."
                </blockquote>
                <aside class="notes">
                    For simplicity's sake, a combinator is a function that uses (composes/combines)
                    other functions to define a result.
                    Note: from https://en.wikipedia.org/wiki/Combinatory_logic
                </aside>
            </section>

            <section>
                <h3>Trying to sequence state functions</h3>
                <pre><code class="scala" data-noescape>
val insert: State[Machine, Unit] = Machine.insertCoin(Coin)
val turn: State[Machine, Candy] = Machine.turn()
  
val program<span class="fragment">: State[Machine, State[Machine, Candy]]</span> =
    insert.map(_ => turn)
                </code></pre>
                <aside class="notes">
                    So map does not work. Might there be another combinator to discover?
                </aside>
            </section>

            <section>
                <h3>Hello FlatMap!</h3>
                <pre><code class="scala" data-noescape>
case class State[S, +A](f: S => (S, A)) {
                    
  def flatMap[B](g: A => State[S, B]): State[S, B] <span class="fragment" data-fragment-index="1">=
    new State(s0 => {
      val (s1, a) = run(s0)</span>
      <span class="fragment" data-fragment-index="2">g(a)</span><span class="fragment"
                                                                      data-fragment-index="3">.run(s1)</span>
    <span class="fragment" data-fragment-index="1">})</span>
}
</span>
<span class="fragment" data-fragment-index="4">
         +---+           +---+         
         |   | ->  s1 -> |   | -> s2 
   s0 -> | f |           | g |         
         |   | ->   a -> |   | -> b
         +---+           +---+         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now looking at flatMap.
                    So the state function takes a state (think machine) and the resulting output of running is a
                    modified state and an a.
                    The function g takes an a and returns a State[S,B]. But a State is just a function from S => (S,A).
                    So in the end we first have to feed the function g an 'a', so we get a new State function.
                    And then 'run' the State function by providing the new State 's' that was the result of running the
                    f-function.
                    This gives us the return value: a tuple of (S,B).

                    Implementing this now, is a piece of cake (a big piece, that is ;-))
                    TODO: 'g' in the ascii art is not entirely correct, applying g(a) gives us a State[S,B]. As we
                    are already wrapping it in a new create State, we would get State[State,B]..?], so the resulting
                    State[S,B] should be run so the function that is wrapped is a 'S => (S,B).
                    Hoe kunnen we dat uitdrukken???
                </aside>
            </section>
            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = insertCoin(Coin)
                     .flatMap(_ => turn())
val (m1, candy) = program.run(m0)

candy shouldBe Candy(BLUE)
                </code></pre>
                <aside class="notes">
                    We have been lying until now, the domain prescribes that we insert a coin first.
                    Remember we get a State[Machine, Unit) as a result. And then we want to turn the machine.
                    As we are not interested in the resulting value of insertCoin (Unit) we disregard the parameter.
                    The State (or the Machine) will be used in the flatMap function.
                    In the end the resulting return type of turn is the State[Machine, Candy], so we know the last
                    validation is successful.
                    Here you see how the state is automatically threaded through the different functions by using the
                    flatMap function.
                </aside>
            </section>
            <section>
                <h3>However, this quickly gets cumbersome...</h3>
                <pre><code class="scala" data-noescape>
val program =
  insertCoin(Coin)
    <span class="fragment" data-fragment-index="1">.flatMap(_ => turn()</span>
      <span class="fragment" data-fragment-index="2">.flatMap(_ => insertCoin(Coin)</span>
        <span class="fragment" data-fragment-index="3">.flatMap(_ => turn())</span>
      <span class="fragment" data-fragment-index="2">)</span>
    <span class="fragment" data-fragment-index="1">)</span>
      
val m0 = Machine(0, candies))
val (m1, candy) = program.run(m0)

candy shouldBe <span class="fragment">Candy(RED)</span>
                </code></pre>
                <aside class="notes">
                    TODO langzaam de flatmaps laten verschijnen!
                    Note how we disregard intermediate values. That is because we are only interested
                    in the end result. This can be a bit confusing. We are not throwing away an end
                    result, we just describe how different functions are chained together. To chain the
                    functions though, we do not need the value produced by the previous one.

                    <code class="scala">
                        val s1 = new State[String, Int](s => (s, s.length))
                        .flatMap[Int](length => new State[String, Int](s => (s, 2 * length)))
                    </code>
                </aside>
            </section>

            <section>
                <h3>For comprehensions to the rescue</h3>
                <pre><code class="scala" data-noescape>
val program = for {
  _ <- insertCoin(Coin)
  _ <- turn()
  _ <- insertCoin(Coin)
  candy <- turn()
} yield candy

val (m1, candy) = program.run(m0)

candy shouldBe Candy(RED)
                </code></pre>
                <aside class="notes">
                    Those familiar with Scala know that flatMaps can be elegantly replaced with a for-comprehension.
                    Look at how imperative this looks, but under the hood it's all functional and immutable.
                    So can we make it even more imperative?
                </aside>
            </section>
        </section>
        <!-- EOF Combinators -->

        <section>
            <section>
                <h3 class="martijn">FP with Getters and Setters</h3>
                <aside class="notes">
                    Martijn
                    That for code already looks more imperative. But can we make it even more imperative?
                    Yes! Welcome our old friends getter and setter!
                </aside>
            </section>
            <section>
                <h3>Now what if we just want to get the state?</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def get[S]: State[S, S] <span class="fragment">= State(s => 
      <span class="fragment">(s, s)</span>
    )</span>
  ...
}
                </code></pre>
            </section>
            <section>
                <h3>And with get comes set</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def set[S](newS: S): State[S, Unit] <span class="fragment">= State(_ => 
      <span class="fragment">(newS, ())</span>
    )</span>
  ...
}
                </code></pre>
            </section>
            <section>
                <h3>Doing the refactoring</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] =
    State(m => (m.copy(coins = m.coins + 1), ()))
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  m <- State.get[Machine]
  u <- State.set(m.copy(coins = m.coins + 1))
} yield u
                </code></pre>
            </section>

            <section>
                <h3>Get and Set == Modify</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def modify[S](f: S => S): State[S, Unit] = 
                    State(s => (f(s), ()))
  ...
}
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = 
  State.modify(m => m.copy(coins = m.coins + 1))
                </code></pre>
            </section>
            <!-- TODO Afsluitende slide met plaatje of iets dergelijks.-->
        </section>

        <section>
            <h3>Automatic wiring with State datatype</h3>
            <table>
                <thead>
                <tr>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>
                        <ul>
                            <li>Simple</li>
                            <li>Immutable</li>
                            <li>Automatic state wiring</li>
                            <li>For-comprehension</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Performance impact</li>
                        </ul>
                    </td>
                </tr>
                </tbody>
            </table>

            <aside class="notes">
                <p>Simple in the sense we are still passing around functions and there are no special Scala constructs
                    used like implicit, type level programming and such.
                    It is not simple if you are not used to this style.
                </p>
            </aside>
        </section>
        <section>
            <h3>The State data type</h3>
            <ul>
                <li>simplifies computations involving state</li>
                <li>while maintaining referential transparency</li>
            </ul>
        </section>


        <section>
            <h2>References</h2>
            <ul>
                </li>
                <li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in
                    Scala</a></li>
                <li><a href="https://www.youtube.com/watch?v=Jg3Uv_YWJqI)">Michael Pilquist - Scalaz State Monad</a>
                </li>
                <li><a href="https://www.youtube.com/watch?v=XxzzJiXHOJs](https://www.youtube.com/watch?v=XxzzJiXHOJs">Brian
                    Beckman: The Zen of Stateless State - The State Monad</a></li>
            </ul>
        </section>

        <section>
            <h2>The end</h2>

            <p>Presentation is available on <br/>
                <a href="https://github.com/aggenebbisj/functionalstate">https://github.com/aggenebbisj/functionalstate</a>
            </p>
        </section>
        <!--
                <section data-background-image="img/the_coming_curse_by_mistabobby1.jpg">
                    <h2>Monadic Curse</h2>
                    <blockquote>
                        once someone learns what monads are
                        and how to use them, <br/>
                        they loose the ability <br/>
                        to explain it to other people.
        
                    </blockquote>
                    <a href="https://www.youtube.com/watch?v=b0EF0VTs9Dc">Douglas Crockford</a>
                    <aside class="notes">
                        [Monads and Gonads - Douglas Crockford](https://www.youtube.com/watch?v=b0EF0VTs9Dc)
                        image from
                        https://contemporaryshaman.files.wordpress.com/2013/11/the_coming_curse_by_mistabobby1.jpg
                    </aside>
                </section>
        -->
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        center: false,
        width: '100%',

        history: true,

        chalkboard: {
            // optionally load pre-recorded chalkboard drawing from file
            // src: "foo.json",
        },

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/chalkboard/chalkboard.js'}
        ],
        keyboard: {
            67: function () {
                RevealChalkboard.toggleNotesCanvas()
            },    // toggle notes canvas when 'c' is pressed
            66: function () {
                RevealChalkboard.toggleChalkboard()
            }, // toggle chalkboard when 'b' is pressed
            46: function () {
                RevealChalkboard.clear()
            },    // clear chalkboard when 'DEL' is pressed
            8: function () {
                RevealChalkboard.reset()
            },    // reset chalkboard data on current slide when 'BACKSPACE' is pressed
            68: function () {
                RevealChalkboard.download()
            }, // downlad recorded chalkboard drawing when 'd' is pressed
        }
    });
</script>
</body>
</html>
