<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom stylesheet -->
    <link rel="stylesheet" href="css/my.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Never change state and still get things done</h1>
            <aside class="notes">
                <strong>Abstract from JFall site</strong>
                <p>
                State can be difficult. Concurrent updates can lead to inconsistency, it can be difficult to scale and have you ever tried
                testing a component with a random element without having to resort to mocking?
                Functional purity can help us here.
                </p>
                <p>
                In this talk, we are going to investigate how we can design a pure functional structure that abstracts
                over state manipulations. We will start with a solution that uses mutable state to solve a problem.
                Then we will refactor step by step and eventually transform it to pure functional code that never
                changes state.
                </p>
                <p>
                Familiarity with lambdas is assumed, but no knowledge of functional programming is required.
                Code examples are in Scala, but no advanced language concepts are used, so knowledge of Java 8 is
                sufficient.
                </p>
                <p>
                As an audience, I would get a comparative overview of solving a problem in a traditional way with
                imperative code and with pure functional structures.
                I would also learn the benefits of purely functional state and its drawbacks.
                </p>
            </aside>
        </section>

        <section>
            <h2>Agenda</h2>

            <ul>
                <li>Traditional OO approach</li>
                <li>Transitioning from mutable to immutable</li>
                <li>Immutable with State data structure</li>

            </ul>
        </section>

        <section>
            <section>
                <h2>The domain</h2>
            </section>

            <section data-background-image="/img/candydispenser.jpg"
                     data-background-size="auto 100%"
                     data-background-color="#ffffff">
                <aside class="notes">
                    <p>A vending machine from which you can buy candies.</p>
                    <p>
                    The vending machine can process two types of inputs from customers.
                        <ol>
                            <li>They can insert money</li>
                            <li>They can turn the knob to get the candy</li>
                        </ol>
                    </p>
                </aside>
            </section>

<!-- TODO the sealed trait is really really ugly -->
            <section>
                <h3><code class="scala">The code</code></h3>
                <pre><code class="scala" data-trim data-noescape>
sealed trait Coin
case object Coin extends Coin

case class Candy(color: String)
                    
val candies = List("Blue", "Red", "White", "Purple", "Green", ...)
                    </code></pre>
                <aside class="notes">
                    <p>We have a simple economy with just one type of coin, just like a festival.</p>
                    <p>The sealed trait is ugly but necessary to prevent <code>Coin.type</code> when matching.</p>
                </aside>
            </section>
        </section>

        <!-- Traditional OO Approach -->
        <section>
            <section>
                <h2>The traditional OO approach</h2>
                <img src="/img/object-oriented-software-construction.jpg"/>
                <aside class="notes">
                    Who knows this classic writing?
                    <ul>
                        <li>First edition written in 1988 by Bertrand Meyer</li>
                        <li>Second edition appeared in 1997 at a whopping 1200 pages</li>
                    </ul>
                    "Meyer pursues the ideal of simple, elegant and user-friendly computer languages and
                    is one of the earliest and most vocal proponents of object-oriented programming (OOP).
                    His book Object-Oriented Software Construction is widely considered to be the best work on
                    presenting the case for OOP."
                    https://en.wikipedia.org/wiki/Bertrand_Meyer
                </aside>
            </section>
            <section>
                <h3>A first attempt: Command/Query Separation</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  private var _lastCandy: Candy = _

  // 'Commands' modify machine
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Unit = { _lastCandy = candies.remove(0) }

  // 'Queries' return information about machine
  def lastCandy = _lastCandy
  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>A ListBuffer is a mutable data structure.</li>
                        <li>Due to command-query separation turn only changes the list of candies and the last candy that was returned.</li>
                        <li>The _(underscore) is necessary to keep the mutable state private.</li>
                    </ul>
                    <p>
                    Meyer p. 748 "The features that characterize a class are divided into commands and queries.
                    A command serves to modify objects, a query to return information about objects."
                    p. 749 A function (defined as routine that returns a result) produces a concrete side effect if its
                    body contains any of the following
                    * an assignment, assignment attempt or creation instruction whose target is an attribute * a
                    procedure call
                    On p. 751 he formulates the 'Command-Query separation principle' as "Functions should not produce
                    abstract side effects"
                    </p>
                    <p>
                    MB: aan de ene kant spreekt dit me wel aan vanwege de Command-Query separation, en dat queries geen
                    side effects zouden mogen hebben
                    aan de andere kant is de volgende slide de meest gebruikte moderne oplossing
                    </p>
                </aside>
            </section>

            <section>
                <h3>A more modern attempt</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    Here the change is that the turn-method return the Candy that falls from the dispenser immediately.
                    The 'command' changes the state and returns information (the dispensed candy)
                </aside>
            </section>


            <section>
                <h3>Taking it for a spin</h3>
                <pre><code class="scala" data-trim data-noescape>
val machine = new Machine(candies, 0)

machine.insertCoin(Coin)
val candy: Candy = machine.turn()

candy shouldBe Candy("Blue")
machine.coins shouldBe 1
                </code></pre>
                <aside class="notes">
                    <code>candies</code> is a mutable list of candies.
                </aside>
            </section>

        </section>
        <!-- EOF Traditional OO Approach -->

        <!-- Problems with traditional approach -->
        <section>
            <section>
                <h2>Problems with the traditional approach</h2>
                <aside class="notes">
                    It has served us well, but in modern times there are some problems and an alternative.
                    "Functional programming was invented in 1957, before structured programming, before object oriented programming.
                    But memory was too expensive to make it practical."
                </aside>
            </section>

            <section>
                <h3>Sharing is no fun</h3>
                <aside class="notes">
                    <ul>
                        <li>Concurrency and shared mutable state don't play nicely together</li>
                        <li>Less of a problem back in the days. Now we have quad-core phones</li>
                    </ul>
                </aside>
            </section>

            <section data-background-image="/img/ache-1297598.svg">
                <h3>It makes your head hurt !!</h3>
                <aside class="notes">Note: With a nice picture of course
                    But, WTF is the problem with the mutable state. It looks completely logical and sound to me.
                    That is, because we are used to the object-oriented way of modelling and looking at things.
                    And no, it is not bad, but there are alternatives that can make easier.
                    So why does it makes your head hurt?
                    From https://pixabay.com/nl/ache-hoofd-menselijke-mannelijke-1297598/
                </aside>
            </section>

            <section>
                <h3>Consider something simple</h3>
                <pre><code class="scala" data-trim data-noescape>
                            def f(x: Int): Int
                                        
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(f(2)) --> 4</span>
                    
                <span class="fragment">f(f(f(2))) --> 5</span>
                </code></pre>

                <aside class="notes">
                    suppose I have a function like this (only the signature)
                    just a very function with an easy signature that takes an Int and returns an Int

                    and I invoke it like below and get as a return 3, and I do the same thing again .... 3

                    what do I expect if I invoke it like twice: 4
                    and of course reading Uncle Bob's clean code I would shout why not call the function addOne
                    but we have our functional mindset now, so we keep the f.
                    And yes the next function we will call g ;-)

                    and we would go on f(f(f(2)))
                    we can reason about it easily.
                </aside>
            </section>
            <section>
                <h3>Now try calling this function more than once...</h3>
                <pre><code class="scala" data-noescape>
var y = 1

def f(x: Int): Int = {
    y = x + y
    y
}               
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 5</span>
                    
                <span class="fragment">f(f(2)) -->14</span>
                    
                <span class="fragment">f(f(f(2))) --> 64</span>
                </code></pre>
                <aside class="notes">
                    This is confusing. The changing of global state is a side-effect which makes it a lot harder to
                    reason about this piece of code. And to calculate the right value you have to know the history of
                    changes.
                    And it doesn't always have to be variables that are global, this also occurs when the scope of the
                    variable is greater than the function it is used in.
                </aside>
            </section>
        </section>
        <!-- EOF Problems with traditional approach -->

        <!-- A more functional approach -->
        <section>
            <section>
                <h2>Taking a more functional approach</h2>
                <aside class="notes">
                    Hardware improvements make FP feasible nowadays. This was different back in the 70's.
                    One of the pillars of FP is referential transparency.
                </aside>
            </section>

            <section>
                <h3>Referential transparency</h3>
                <blockquote>
                    An expression is said to be <br/>
                    referentially transparent<br/>
                    if it can be <strong>replaced</strong><br/>
                    with its corresponding value<br/>
                    <strong>without changing</strong> the program's behavior
                </blockquote>

                <aside class="notes">
                    Calling a function with the same arguments will return the same result every time.

                    This means that you have no assignments that change the global change.
                    This is why immutability is so important.

                    But it also has more impact. For example on exceptions (try/catch semantics).
                </aside>
            </section>
            <section>
                <h3>Benefits of Referential Transparency</h3>

                <ul>
                    <li>Easier to reason about</li>
                    <li>Testable</li>
                    <li>Composable</li>
                    <li>Parallellizable</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Reason: you can replace stuff and use induction</li>
                        <li>Test: you can do blackbox testing: data in, data out</li>
                        <li>Composable: functions play nice, just align the types</li>
                        <li>Parallellizable: no shared mutable state</li>
                    </ul>
                    Note: * Modular why? What are the benefits?
                    Looking at the red book (p. 79), they argue that
                    the lack of referential transparency implies that the code is not as testable, composable, modular
                    and easily parallelized as it could be.
                </aside>
            </section>

        </section>
        <!-- EOF A more functional approach -->

        <!-- Introducing immutability -->
        <section>
            <section>
                <h2>Stop trying to change me</h2>
                <aside class="notes">
                    Note: catchy title ;-)
                    *edit* How's this?
                </aside>
            </section>

            <section>
                <h3>Remember?</h3>
                <pre><code class="scala" data-noescape>            
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def remainingCandies = candies.size
  def coins = _coins
}
            </code></pre>
            </section>

            <section data-autoslide="2000">
                <h3>Copy on write</h3>
                <pre><code class="scala" data-noescape>
case class Machine(candies: List[Candy], coins: Int)

  
object Machine {
  
  def turn(m: Machine): (Machine, Candy) = 
    (m.copy(candies = m.candies.tail), m.candies.head)

  def insertCoin(coin: Coin, m: Machine): (Machine) =
    m.copy(coins = m.coins + 1)
}
            </code></pre>
                <aside class="notes">
                    We have to introduce companion object and case class (with copy, public val attributes) here.
                    Best explained for Java people as an object to hold your static methods.
                    We need the methods out of Machine case class to prepare for type signature of State Monad.
                </aside>
            </section>

            <section>
                <h3>Immutable drive</h3>
                <pre><code class="scala" data-noescape>        
val m0 = Machine(candies, 0)

val m1:Machine   = Machine.insertCoin(Coin, m0)
val (m2, candy0) = Machine.turn(m1)

val m3           = Machine.insertCoin(Coin, m2)
val (m4, candy1) = Machine.turn(<span class="fragment highlight-red">m1</span>)

m4.coins shouldBe 2
m4.candies.size shouldBe 6
            </code></pre>
                <aside class="notes">
                    TODO fix test shouldBe 6 (test ex machina)
                    <p>Everything is now immutable, but wiring the state through all the function calls is tedious.
                    And error prone: Do you spot the bug?</p>
                    <p>The other thing to notice is that this still looks like the imperative way of programming (do this and then do that).
                        However, we do not mutate in place, but apply functions and assign them to new variables.
                    </p>
                </aside>
            </section>

            <section>
                <table>
                    <thead>
                    <tr>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <ul>
                                <li>Simple</li>
                                <li>Immutable</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Error prone</li>
                            </ul>
                        </td>
                    </tr>
                    </tbody>
                </table>

                <aside class="notes">
                    Note: manual wiring of state through all the calls is error-prone
                </aside>
            </section>
        </section>
        <!-- EOF Introducing immutability -->

        <!-- Using a Functional State Data Structure -->
        <section>
            <section>
                <h2>Functional State</h2>
                <aside class="notes">
                </aside>
            </section>


            <section>
                <h3>Let's look at the type signature</h3>

                <pre><code class="scala" data-noescape>
def turn(m: Machine): (Machine, Candy)
                </code></pre>
            </section>

            <section>
                <h3><code class="scala">Machine => (Machine, Candy)</code></h3>
                <aside class="notes">
                    We are separating the declaration of the manipulation and the computation/the moment that the manipulation is applied.
                </aside>
            </section>

            <section>
                <h3><code class="scala">S<span style="color: red" class="fragment" data-fragment-index="1">1</span> => (S<span style="color: red" class="fragment" data-fragment-index="1">2</span>, A)</code></h3>
                <aside class="notes">
                    Or more abstract, we got a function that takes something that represents the State with an output
                    of a tuple of a new State and a value.
                    This is going to be are basic abstract, a function from a State to a new State and a value.
                </aside>
            </section>

            <section>
                <h3>Let's wrap this in a class</h3>

                <pre><code class="scala" data-noescape>      
class State[S, +A](f: S => (S, A)) {
        
  def run(initial: S): (S, A) = f(initial)
        
}
            </code></pre>
                <aside class="notes">
                    NB: <code class="scala">new State(f).run(s) == f(s)</code>
                    <p>
                    TODO should we get rid of the +A covariance for simplicity?
                    So we have a class State with two Type parameters S and A for the State and the value.
                    The constructor of the class does not take a regular value, but it takes that function
                    from a State to a new State and value.
                    </p>
                    <p>
                    Creating the State does not do anything useful yet.
                    Run will just apply that function and thus return a tuple of a new state and a value.
                    </p>
                    <p>
                    Without combinators the class does not do much of course.
                    We need the class because unlike JavaScript we cannot add methods to functions.
                    </p>
                </aside>
            </section>

            <section>
                <h3>Refactor the current turn method</h3>
                <div style="position: relative">
                <pre class="fragment fade-out" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="0"><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
  def turn(m: Machine): (Machine, Candy) = 
    (m.copy(candies = m.candies.tail), m.candies.head)
                </code></pre>
                <pre class="fragment fade-in" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="0"><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
  def turn(): State[Machine, Candy] = <span class="fragment fade-out">new </span>State(m => 
    (m.copy(candies = m.candies.tail), m.candies.head)
  )
                </code></pre>
                </div>
                <aside class="notes">
                    If we add an apply function we can even remove the 'new'
                    And again, calling Machine.turn() does not do anything. It just defines a function that will
                    do something WHEN it is applied with a machine.
                    This is shown below, when the run method is called with a machine, then the result is calculated.
                </aside>
            </section>

            <section>
                <h3>Ok, but what about inserting a Coin?</h3>
                <pre><code class="scala" data-noescape>
object Machine {
  def insertCoin(coin: Coin<span class="fragment" data-fragment-index="2">)</span><span class="fragment fade-out"
                                                                                        data-fragment-index="2">,</span><span
                        class="fragment" data-fragment-index="2">(</span>m: Machine): <span class="fragment"
                                                                                            data-fragment-index="1">(</span>Machine<span
                        class="fragment" data-fragment-index="1">, Unit)</span> = 
                 </code></pre>
                <aside class="notes">
                    This does not look like a function S => (S,A),
                    but looking at it more abstractly: the return value from insertCoin is nothing or Unit.
                    And if we are going to use currying of the parameters, we get two parameter lists, with one
                    that is equal to the State datatype we created.
                    So, here we can also refactor it to use the State data type we created.
                    TODO needs some explaining about currying.
                </aside>
            </section>

            <section>
                <h3>Doing the mechanical refactoring</h3>
                <div style="position: relative">
                <pre class="fragment fade-out" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="0"><code class="scala" data-noescape>
object Machine {
  
  ...

  def insertCoin(coin: Coin, m: Machine): Machine =
    m.copy(coins = m.coins + 1)
}
                </code></pre>
                <pre class="fragment fade-in" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;" data-fragment-index="0"><code class="scala" data-noescape>
object Machine {
  
  ...

  def insertCoin(coin: Coin): State[Machine, Unit] = State(m => (
    m.copy(coins = m.coins + 1), ())
  )
}
                </code></pre>
                <aside class="notes">
                    So inserting a coin basically return a datatype holding a function that will take a machine as a
                    parameter and return a new machine with increased number of coins and no concrete value to return.
                </aside>
            </section>

            <section data-background-image="img/camron_u_mad.jpg">
                <h3>Now hold on a minute...</h3>
                <h4>Didn't you just make it more complex?</h4>
                <aside class="notes">
                    Yes we did make it more complex, but...
                    This allows us to use combinators (which allow us to rewrite this into something nicer)
                    Background: u mad meme: http://nymag.com/selectall/2015/12/nine-canonical-responses-to-u-mad.html
                </aside>
            </section>
        </section>
        <!-- EOF Using a Functional State Data Structure -->

        <!-- Combinators -->
        <section>
            <section>
                <h2>Combinators</h2>
                <blockquote>"A combinator is a higher-order function <br/>
                    that uses only function application and<br/>
                    earlier defined combinators<br/>
                    to define a result from its arguments."
                </blockquote>
                <aside class="notes">
                    Note: from https://en.wikipedia.org/wiki/Combinatory_logic
                </aside>
            </section>

            <section>
                <h3>map</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def map[B](transform: A => B): State[S, B] <span class="fragment" data-fragment-index="2">=
    new State[S, B](s0 => {
      val (s1, a) = run(s0)
      (s1, transform(a))
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----                    
         |   | -----------------------> s1 
   s0 -> | f |         -------------         
         |   | -> a -> | transform | ->  b
         -----         -------------         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now it's getting interesting. What if we want to combine and transform the value.
                    What if we, when running the state function would like to transform the resulting value.
                    Just like with a List we can do that with the map function.
                    How does it look like graphically? We have a machine that we give to the run-function of the State
                    (which basically applies f to s0).
                    The run function delivers a new State (machine) and a value 'a'. The value a is transformed by the
                    map-function to a b.
                </aside>
            </section>
            <section>
                <h3>Spin it</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val turn   : State[Machine, Candy] = Machine.turn()
val program: State[Machine, String] = turn.map(_.color)
val (m1, color) = program.run(m0)

color shouldBe "Blue"
                </code></pre>
                <aside class="notes">
                    So we have now a new function that combines the turn function with a function that transforms the
                    resulting output.
                    And we can write this more succintly as the Scala compiler can infers most types.
                </aside>
            </section>

            <section>
                <h3>Or more ideomatic</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = Machine.turn().map(_.color)
val (m1, color) = program.run(m0)
      
color shouldBe "Blue"
                </code></pre>
            </section>

            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def flatMap[B](g: A => State[S, B]): State[S, B] <span class="fragment" data-fragment-index="2">=
    State(s0 => {
      val (s1, a) = run(s0)
      g(a).run(s1)
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----           -----         
         |   | ->  s1 -> |   | -> s2 
   s0 -> | f |           | g |         
         |   | ->   a -> |   | -> b
         -----           -----         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now looking at flatMap.
                    So the state function takes a state (think machine) and the resulting output of running is a
                    modified state and an a.
                    The function g takes an a and returns a State[S,B]. But a State is just a function from S => (S,A).
                    So in the end we first have to feed the function g an 'a', so we get a new State function.
                    And then 'run' the State function by providing the new State 's' that was the result of running the
                    f-function.
                    This gives us the return value: a tuple of (S,B).

                    Implementing this now, is a piece of cake (a big piece, that is ;-))
                    TODO: 'g' in the ascii art is not entirely correct, applying g(a) gives us a State[S,B]. As we
                    are already wrapping it in a new create State, we would get State[State,B]..?], so the resulting
                    State[S,B] should be run so the function that is wrapped is a 'S => (S,B).
                    Hoe kunnen we dat uitdrukken???
                </aside>
            </section>
            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = Machine.insertCoin(Coin)
                     .flatMap(_ => Machine.turn())
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Blue")
                </code></pre>
                <aside class="notes">
                    We have been lying until now, the domain prescribes that we insert a coin first.
                    Remember we get a State[Machine, Unit) as a result. And then we want to turn the machine.
                    As we are not interested in the resulting value of insertCoin (Unit) we disregard the parameter.
                    The State (or the Machine) will be used in the flatMap function.
                    In the end the resulting return type of turn is the State[Machine,Candy], so we the last validation
                    is successfull.
                </aside>
            </section>
            <section>
                <h3>This is getting cumbersome</h3>
                <pre><code class="scala" data-noescape>
val program =
  Machine.insertCoin(Coin)
    .flatMap(_ => Machine.turn()
      .flatMap(_ => Machine.insertCoin(Coin)
        .flatMap(_ => Machine.turn())))
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                </aside>
            </section>


            <section>
                <h3>Using for comprehensions</h3>
                <pre><code class="scala" data-noescape>
val program = for {
  _ <- insertCoin(Coin)
  _ <- turn()
  _ <- insertCoin(Coin)
  candy <- turn()
} yield candy

val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                    For those familiar with Scala know that flatMaps can be elegantly replaced with a for-comprehension.
                </aside>
            </section>
            <section>
                <h3>FP with Getters and Setters</h3>
                <aside class="notes">
                    That for code already looks more imperative. But can we make it even more imperative?
                    Yes! Welcome our old friends getter and setter!
                </aside>
            </section>
            <section>
                <h3>Now what if we just want to get the state?</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def get[S]: State[S, S] = new State(s => (s, s))
  ...
}
                </code></pre>      
            </section>
            <section>
                <h3>And with get comes set</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def set[S](newS: S): State[S, Unit] = new State(_ => (newS, ()))
  ...
}
                </code></pre>      
            </section>
            <section>
                <h3>Doing the refactoring</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] =
    State(m => (m.copy(coins = m.coins + 1), ()))
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  m <- State.get[Machine]
  u <- State.set(m.copy(coins = m.coins + 1))
} yield u
                </code></pre>
            </section>

            <section>
                <h3>Get and Set == Modify</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def modify[S](f: S => S): State[S, Unit] = 
                    new State(s => (f(s), ()))
  ...
}
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  u <- State.modify[Machine](m => m.copy(coins = m.coins + 1))
} yield u
                </code></pre>
            </section>

        </section>
        <!-- Combinators -->
        <section>
            <table>
                <thead>
                    <tr>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>
                            <ul>
                                <li>Simple</li>
                                <li>Immutable</li>
                                <li>Automatic state wiring</li>
                                <li>For-comprehension</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Performance impact</li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>

            <aside class="notes">
                <p>Simple in the sense we are still passing around functions and there are no special Scala constructs used
                    like implicit, type level programming and such
                    It is not simple if you are not used to this style.
                </p>
            </aside>
        </section>
        <section>
            <h3>Summary</h3>
            <ul>
                <li>simplifies computations on state</li>
                <li>while maintaining referential transparency</li>
            </ul>
        </section>


        <section>
            <h3>References</h3>
            <ul>
                <li><a href="https://github.com/aggenebbisj/functionalstate">https://github.com/aggenebbisj/functionalstate</a></li>
                <li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in
                    Scala</a></li>
                <li><a href="https://www.youtube.com/watch?v=Jg3Uv_YWJqI)">Michael Pilquist - Scalaz State Monad</a>
                </li>
                <li><a href="https://www.youtube.com/watch?v=XxzzJiXHOJs](https://www.youtube.com/watch?v=XxzzJiXHOJs">Brian
                    Beckman: The Zen of Stateless State - The State Monad</a></li>
                
            </ul>
        </section>

<!-- CAN BE REMOVED LATER ON
        <section data-markdown="presentation.md"
                 data-separator="^---"
                 data-separator-vertical="^\n\n"
                 data-separator-notes="^Note:"
                 data-charset="UTF8"
                 data-state="mybackground"
                 data-background-image="img/stars.svg"
                 data-background-position="top left"
                 data-background-size="800px">
        </section>
-->

        <section data-background-image="img/the_coming_curse_by_mistabobby1.jpg">
            <h2>Monadic Curse</h2>
            <blockquote>
                once someone learns what monads are
                and how to use them, <br/>
                they loose the ability <br/>
                to explain it to other people.

            </blockquote>
            <a href="https://www.youtube.com/watch?v=b0EF0VTs9Dc">Douglas Crockford</a>
            <aside class="notes">
                [Monads and Gonads - Douglas Crockford](https://www.youtube.com/watch?v=b0EF0VTs9Dc)
                image from
                https://contemporaryshaman.files.wordpress.com/2013/11/the_coming_curse_by_mistabobby1.jpg
            </aside>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,
        
        chalkboard: {
            // optionally load pre-recorded chalkboard drawing from file
            src: "foo.json",
        },

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            { src: 'plugin/markdown/marked.js' },
            { src: 'plugin/markdown/markdown.js' },
            { src: 'plugin/notes/notes.js', async: true },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            },
            { src: 'plugin/chalkboard/chalkboard.js' }
        ],
        keyboard: {
            67: function() { RevealChalkboard.toggleNotesCanvas() },    // toggle notes canvas when 'c' is pressed
            66: function() { RevealChalkboard.toggleChalkboard() }, // toggle chalkboard when 'b' is pressed
            46: function() { RevealChalkboard.clear() },    // clear chalkboard when 'DEL' is pressed
             8: function() { RevealChalkboard.reset() },    // reset chalkboard data on current slide when 'BACKSPACE' is pressed
            68: function() { RevealChalkboard.download() }, // downlad recorded chalkboard drawing when 'd' is pressed
        }
    });
</script>
</body>
</html>
