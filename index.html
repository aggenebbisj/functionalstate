<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Custom stylesheet -->
    <link rel="stylesheet" href="css/my.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Never change state</h1>
            <h2>and still get things done</h2>
            <br/>
            <br/>
            <table>
                <thead>
                <tr>
                    <th>Remko de Jong</th>
                    <th>Martijn Blankestijn</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>
                        <a href="https://www.siteworkers.nl/">
                            <div class="logo">
                                <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg"  height="6em" x="0px" y="0px" viewBox="0 0 55.1 125.6" enable-background="new 0 0 55.1 125.6" xml:space="preserve"><g><path d="M3.2,69l52-15.1L29,0l0,0l0,0l0,0l0,0C28.6,0.4,0.4,34,0.2,34.2L0,34.4l2.7,34.7l0,0l0,0l0,0L3.2,69zM1,34.7c0.7-0.8,4.4-5.2,26.9-31.9L3.5,66.9L1,34.7z"></path><g><path d="M5.7,87.6c0-1.3,0.8-1.9,2.3-1.9c0.5,0,1.2,0.1,1.9,0.4L9.6,87c-0.7-0.2-1.3-0.3-1.7-0.3c-0.4,0-0.7,0.1-0.9,0.2c-0.2,0.1-0.3,0.4-0.3,0.7c0,0.2,0.1,0.4,0.3,0.6c0.2,0.2,0.5,0.3,1,0.4c0.7,0.2,1.2,0.4,1.5,0.7c0.3,0.3,0.4,0.8,0.4,1.4c0,1.3-0.8,2-2.4,2c-0.5,0-1.2-0.1-2-0.3l0.2-1c0,0,0.1,0,0.3,0.1c0.7,0.2,1.2,0.3,1.6,0.3c0.4,0,0.6-0.1,0.8-0.3c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.2-0.7c-0.2-0.2-0.4-0.3-0.9-0.4c-0.7-0.2-1.3-0.5-1.6-0.8C5.9,88.6,5.7,88.1,5.7,87.6z"></path><path d="M17.6,92.6v-1h1.3v-4.9h-1.3v-1h3.7v1H20v4.9h1.2v1H17.6z"></path><path d="M28.6,86.7v-1h4.6v1h-1.8v5.8h-1.1v-5.8H28.6z"></path><path d="M40.5,92.6v-6.8h4v1h-2.9v1.9h2.6v0.9h-2.6v2h2.9v1H40.5z"></path><path d="M5.9,109l-0.6-6.8h1l0.5,5.9h0.1l0.6-3h0.9l0.6,3h0.1l0.4-5.9h1L10,109H8.4l-0.5-2.7h0L7.4,109H5.9z"></path><path d="M19.4,109.1c-0.8,0-1.4-0.3-1.8-0.9c-0.4-0.6-0.5-1.5-0.5-2.7c0-1.2,0.2-2.1,0.6-2.6c0.4-0.6,1-0.8,1.8-0.8c0.8,0,1.4,0.3,1.8,0.8c0.4,0.5,0.5,1.4,0.5,2.7c0,1.2-0.2,2.1-0.5,2.7C20.9,108.9,20.3,109.1,19.4,109.1z M19.4,108.2c0.5,0,0.8-0.2,1-0.5c0.2-0.4,0.3-1,0.3-2c0-1-0.1-1.7-0.3-2c-0.2-0.3-0.5-0.5-1-0.5s-0.8,0.2-1,0.5c-0.2,0.4-0.3,1-0.3,1.9c0,0.9,0.1,1.6,0.2,2C18.6,108,18.9,108.2,19.4,108.2z"></path><path d="M30.9,106.6c-0.4,0-0.6,0-0.6,0h-0.5v2.5h-1.1v-6.8h2.1c0.8,0,1.3,0.2,1.7,0.5c0.4,0.3,0.6,0.9,0.6,1.7c0,0.9-0.4,1.5-1.2,1.9c0.5,0.9,0.9,1.8,1.2,2.7h-1.2C31.7,108.2,31.4,107.4,30.9,106.6z M30.7,103.2h-0.9v2.4h0.9c0.9,0,1.4-0.4,1.4-1.2c0-0.4-0.1-0.8-0.3-0.9C31.5,103.3,31.2,103.2,30.7,103.2z"></path><path d="M40.5,109v-6.8h1.1v3l0.6-0.1c0.4-0.7,0.9-1.5,1.4-2.4l0.2-0.5h1.2c-0.7,1.4-1.3,2.5-1.9,3.3c0.2,0.3,0.5,0.8,0.8,1.4L45,109h-1.2c-0.7-1.4-1.2-2.3-1.6-2.9l-0.6,0.1v2.9H40.5z"></path><path d="M5.9,125.5v-6.8h4v1H7v1.9h2.6v0.9H7v2h2.9v1H5.9z"></path><path d="M19.4,123c-0.4,0-0.6,0-0.6,0h-0.5v2.5h-1.1v-6.8h2.1c0.8,0,1.3,0.2,1.7,0.5c0.4,0.3,0.6,0.9,0.6,1.7c0,0.9-0.4,1.5-1.2,1.9c0.5,0.9,0.9,1.8,1.2,2.7h-1.2C20.2,124.7,19.8,123.8,19.4,123z M19.1,119.7h-0.9v2.4h0.9c0.9,0,1.4-0.4,1.4-1.2c0-0.4-0.1-0.8-0.3-0.9C20,119.8,19.6,119.7,19.1,119.7z"></path><path d="M28.8,120.5c0-1.3,0.8-1.9,2.3-1.9c0.5,0,1.2,0.1,1.9,0.4l-0.2,0.9c-0.7-0.2-1.3-0.3-1.7-0.3c-0.4,0-0.7,0.1-0.9,0.2c-0.2,0.1-0.3,0.4-0.3,0.7c0,0.2,0.1,0.4,0.3,0.6c0.2,0.2,0.5,0.3,1,0.4c0.7,0.2,1.2,0.4,1.5,0.7s0.4,0.8,0.4,1.4c0,1.3-0.8,2-2.4,2c-0.5,0-1.2-0.1-2-0.3l0.2-1c0,0,0.1,0,0.3,0.1c0.7,0.2,1.2,0.3,1.6,0.3c0.4,0,0.6-0.1,0.8-0.3c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.2-0.7c-0.2-0.2-0.4-0.3-0.9-0.4c-0.7-0.2-1.3-0.5-1.6-0.8C29,121.5,28.8,121.1,28.8,120.5z"></path></g></g></svg>
                            </div>
                    <td><img src="img/logo-simple.svg"
                             style="border: none; background-color: transparent; vertical-align: middle"
                             height="75em"/></a></td>
                </tr>
                </tbody>
            </table>
            <aside class="notes">
                <ul>
                    <li>Experience with function state in a real-life project, implementation and simulation of the order of flyers </li>
                    <li>Preferably questions at the end</li>
                </ul>
                <strong>Abstract from JFall site</strong>
                <p>
                    State can be difficult. Concurrent updates can lead to inconsistency, it can be difficult to scale
                    and have you ever tried testing a component with a random element without having to resort to
                    mocking?
                    Functional purity can help us here.
                </p>
                <p>
                    In this talk, we are going to investigate how we can design a pure functional structure that
                    abstracts over state manipulations. We will start with a solution that uses mutable state to solve a
                    problem.
                    Then we will refactor step by step and eventually transform it to pure functional code that never
                    changes state.
                </p>
                <p>
                    Familiarity with lambdas is assumed, but no knowledge of functional programming is required.
                    Code examples are in Scala, but no advanced language concepts are used, so knowledge of Java 8 is
                    sufficient.
                </p>
                <p>
                    As an audience, I would get a comparative overview of solving a problem in a traditional way with
                    imperative code and with pure functional structures.
                    I would also learn the benefits of purely functional state and its drawbacks.
                </p>
                <p>
                    Time schedule
                                                        # Minuten	Totaal
                    Presentatie onderdelen			                0
                    Intro / Agenda	                             2	2
                    Domain / Traditional approach + nadelen	M	10	12
                    More functional approach / pros/cons 	S	6	18
                    Functional staTe                      	M	8	26
                    Combinators	                            S	12	38
                    FP with Getters and Setters	            M/S	5	43
                    Pro / Cons summary                  		2	45
                </p>
            </aside>
        </section>

        <section>
            <h2>Agenda</h2>

            <ul>
                <li>Traditional OO approach</li>
                <li>Transitioning from mutable to immutable</li>
                <li>Immutable with State data structure</li>

            </ul>
        </section>

        <section>
            <section>
                <h2>The domain</h2>
            </section>

            <section data-background-image="/img/candydispenser.jpg"
                     data-background-size="auto 100%"
                     data-background-color="#ffffff">
                <aside class="notes">
                    <p>A vending machine from which you can buy candies.</p>
                    <p>
                        The vending machine can process two types of inputs from customers. A customer can
                    </p>
                    <ol>
                        <li>insert money</li>
                        <li>turn the knob to get the candy</li>
                    </ol>
                </aside>
            </section>

            <!-- TODO the sealed trait is really really ugly -->
            <section>
                <h3><code class="scala">The code</code></h3>
                <pre><code class="scala" data-trim data-noescape>
sealed trait Coin
case object Coin extends Coin

case class Candy(color: String)
                    
val candies = List(Candy("Blue"), Candy("Red"), ...)
                    </code></pre>
                <aside class="notes">
                    <p>We have a simple economy with just one type of coin, just like a festival.</p>
                    <p>The sealed trait is ugly but necessary to prevent <code>Coin.type</code> when matching.</p>
                </aside>
            </section>
        </section>

        <!-- Traditional OO Approach -->
        <section>
            <section>
                <h2>The traditional OO approach</h2>
                <img src="/img/object-oriented-software-construction.jpg"/>
                <aside class="notes">
                    <p>Who knows this classic writing? Betrand Meyer (1: 1988, 2: 1997)</p>
                    <p>Command-Query separation principle: Features of a class are</p>
                    <ul>
                        <li><strong>Commands</strong> modify objects, but do <em>not</em> return results</li>
                        <li><strong>Queries</strong> return information about object and should not produce a side effect</li>
                    </ul>
                    <ul>
                        <li>First edition written in 1988 by Bertrand Meyer</li>
                        <li>Second edition appeared in 1997 at a whopping 1200 pages</li>
                    </ul>
                    <p>
                    <p>
                        Meyer p. 748 "The features that characterize a class are divided into commands and queries.
                        A command serves to modify objects, a query to return information about objects."
                        p. 749 A function (defined as routine that returns a result) produces a concrete side effect if
                        its body contains any of the following
                        * an assignment, assignment attempt or creation instruction whose target is an attribute * a
                        procedure call
                        On p. 751 he formulates the 'Command-Query separation principle' as "Functions should not
                        produce abstract side effects"
                    </p>

                    <p>
                    "Meyer pursues the ideal of simple, elegant and user-friendly computer languages and
                    is one of the earliest and most vocal proponents of object-oriented programming (OOP).
                    His book Object-Oriented Software Construction is widely considered to be the best work on
                    presenting the case for OOP."
                    https://en.wikipedia.org/wiki/Bertrand_Meyer</p>
                </aside>
            </section>
            <section>
                <h3>A first attempt: Command/Query Separation</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  private var _lastCandy: Candy = _

  // 'Commands' modify machine
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Unit = { _lastCandy = candies.remove(0) }

  // 'Queries' return information about machine
  def lastCandy = _lastCandy
  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    <ul>
                        <li>A ListBuffer is a mutable data structure.</li>
                        <li>Due to command-query separation turn only changes the list of candies and the last candy
                            that was returned.
                        </li>
                        <li>The _(underscore) is necessary to keep the mutable state private.</li>
                    </ul>
                    <p>
                        MB: aan de ene kant spreekt dit me wel aan vanwege de Command-Query separation, en dat queries
                        geen
                        side effects zouden mogen hebben
                        aan de andere kant is de volgende slide de meest gebruikte moderne oplossing
                    </p>
                </aside>
            </section>

            <section>
                <h3>A more modern attempt</h3>
                <pre><code class="scala" data-trim data-noescape>
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def coins = _coins
}
                </code></pre>
                <aside class="notes">
                    Here the change is that the turn-method return the Candy that falls from the dispenser immediately.
                    The 'command' changes the state and returns information (the dispensed candy)
                </aside>
            </section>


            <section>
                <h3>Taking it for a spin</h3>
                <pre><code class="scala" data-trim data-noescape>
val machine = new Machine(candies, 0)

machine.insertCoin(Coin)
val candy: Candy = machine.turn()

candy shouldBe Candy("Blue")
machine.coins shouldBe 1
                </code></pre>
                <aside class="notes">
                    <code>candies</code> is a mutable list of candies.
                </aside>
            </section>

        </section>
        <!-- EOF Traditional OO Approach -->

        <!-- Problems with traditional approach -->
        <section>
            <section>
                <h2>Problems with the traditional approach</h2>
                <aside class="notes">
                    It has served us well, but in modern times there are some problems and an alternative.
                    "Functional programming was invented in 1957, before structured programming, before object oriented
                    programming.
                    But memory was too expensive to make it practical."
                </aside>
            </section>

            <section>
                <h3>Sharing is no fun</h3>
                <aside class="notes">
                    <ul>
                        <li>Concurrency and shared mutable state don't play nicely together</li>
                        <li>Less of a problem back in the days. Now we have quad-core phones</li>
                    </ul>
                </aside>
            </section>

            <section data-background-image="/img/ache-1297598.svg">
                <h3>It makes your head hurt !!</h3>
                <aside class="notes">Note: With a nice picture of course
                    But, WTF is the problem with the mutable state. It looks completely logical and sound to me.
                    That is, because we are used to the object-oriented way of modelling and looking at things.
                    And no, it is not bad, but there are alternatives that can make easier.
                    So why does it makes your head hurt?
                    From https://pixabay.com/nl/ache-hoofd-menselijke-mannelijke-1297598/
                </aside>
            </section>

            <section>
                <h3>Consider something simple</h3>
                <pre><code class="scala" data-trim data-noescape>
                            def f(x: Int): Int
                                        
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(f(2)) --> 4</span>
                    
                <span class="fragment">f(f(f(2))) --> 5</span>
                </code></pre>

                <aside class="notes">
                    suppose I have a function like this (only the signature)
                    just a very function with an easy signature that takes an Int and returns an Int

                    and I invoke it like below and get as a return 3, and I do the same thing again .... 3

                    what do I expect if I invoke it like twice: 4
                    and of course reading Uncle Bob's clean code I would shout why not call the function addOne
                    but we have our functional mindset now, so we keep the f.
                    And yes the next function we will call g ;-)

                    and we would go on f(f(f(2)))
                    we can reason about it easily.
                </aside>
            </section>
            <section>
                <h3>Now try calling this function more than once...</h3>
                <pre><code class="scala" data-noescape>
var y = 1

def f(x: Int): Int = {
    y = x + y
    y
}               
                <span class="fragment">f(2) --> 3</span>
                    
                <span class="fragment">f(2) --> 5</span>
                    
                <span class="fragment">f(f(2)) -->14</span>
                    
                <span class="fragment">f(f(f(2))) --> 64</span>
                </code></pre>
                <aside class="notes">
                    <p>This is confusing. The changing of state with a wider scope than the function is a side-effect
                        which makes it a lot harder to reason about this piece of code.
                        And to calculate the right value you have to know the history of changes.</p>
                    <p>And it doesn't always have to be variables that are global, this also occurs when the scope of
                        the variable is greater than the function it is used in.</p>
                </aside>
            </section>
        </section>
        <!-- EOF Problems with traditional approach -->

        <!-- A more functional approach -->
        <section>
            <section>
                <h2>Taking a more functional approach</h2>
                <aside class="notes">
                    Hardware improvements make FP feasible nowadays. This was different back in the 70's.
                    One of the pillars of FP is referential transparency.
                </aside>
            </section>

            <section>
                <h3>Referential transparency</h3>
                <blockquote>
                    An expression is said to be <br/>
                    referentially transparent<br/>
                    if it can be <strong>replaced</strong><br/>
                    with its corresponding value<br/>
                    <strong>without changing</strong> the program's behavior
                </blockquote>

                <aside class="notes">
                    Calling a function with the same arguments will return the same result every time.

                    This means that you have no assignments that change the global change.
                    This is why immutability is so important.

                    But it also has more impact. For example on exceptions (try/catch semantics).
                </aside>
            </section>
            <section>
                <h3>Benefits of Referential Transparency</h3>

                <ul>
                    <li>Easier to reason about</li>
                    <li>Testable</li>
                    <li>Composable</li>
                    <li>Parallellizable</li>
                </ul>
                <aside class="notes">
                    <ul>
                        <li>Reason: you can replace stuff and use induction</li>
                        <li>Test: you can do blackbox testing: data in, data out</li>
                        <li>Composable: functions play nice, just align the types</li>
                        <li>Parallellizable: no shared mutable state</li>
                    </ul>
                    Note: * Modular why? What are the benefits?
                    Looking at the red book (p. 79), they argue that
                    the lack of referential transparency implies that the code is not as testable, composable, modular
                    and easily parallelized as it could be.
                </aside>
            </section>

        </section>
        <!-- EOF A more functional approach -->

        <!-- Introducing immutability -->
        <section>
            <section>
                <h2>Stop trying to change me</h2>
                <aside class="notes">
                    Note: catchy title ;-)
                    *edit* How's this?
                </aside>
            </section>

            <section>
                <h3>Remember?</h3>
                <pre><code class="scala" data-noescape>            
class Machine(private val candies: ListBuffer[Candy],
              private var _coins: Int) {
  
  def insertCoin(coin: Coin): Unit = _coins = _coins + 1
  def turn(): Candy = candies.remove(0)

  def remainingCandies = candies.size
  def coins = _coins
}
            </code></pre>
            </section>

            <section>
                <h3>Copy on write</h3>
                <pre><code class="scala" data-noescape>
case class Machine(candies: List[Candy], coins: Int)

  
object Machine {
  
  def turn(m: Machine): (Machine, Candy) = 
    (m.copy(candies = m.candies.tail), m.candies.head)

  def insertCoin(coin: Coin, m: Machine): Machine =
    m.copy(coins = m.coins + 1)
}
            </code></pre>
                <aside class="notes">
                    <p>Noteworthy is the 'case' modifier in front of Machine.
                        The Scala compiler will add some synctactic conveniences to that class like:
                    </p>
                    <ul>
                        <li>a factory method (no new keyword needed)</li>
                        <li>all arguments in the parameter list are implicitly val's, so immutable</li>
                        <li>adds a copy method for making modified copies</li>
                    </ul>

                    <p>The keyword 'object' indicates that something is not a class, but a singleton.
                        If it has the same name as a class in the same file, it is called the <em>companion object</em>,
                        because both can access eachothers private members</p>
                    <p>
                        We need the methods out of Machine case class to prepare for type signature of State Monad.</p>
                    <p>We have now made the state explicit by adding it as an argument and return type to every function call.
                    Tbe state is not longer implicit, hidden within some object that will be updated. It is made explicit</p>
                </aside>
            </section>

            <section>
                <h3>Immutable drive</h3>
                <pre><code class="scala" data-noescape>        
val m0 = Machine(candies, 0)

val  m1: Machine   = Machine.insertCoin(Coin, m0)
val (m2, candy0)   = turn(m1)

val  m3            = insertCoin(Coin, m2)
val (m4, candy1)   = turn(<span class="fragment highlight-red">m1</span>)

m4.coins shouldBe 2
m4.candies.size shouldBe 6
            </code></pre>
                <aside class="notes">
                    TODO fix test shouldBe 6 (test ex machina)
                    <p>While inserting the first Coin we show the types and singleton object in which the function is
                        defined,
                        in lines after that we import those functions and let the compiler figure it out.</p>
                    <p>Everything is now immutable, but wiring the state through all the function calls is tedious.
                        And error prone: Do you spot the bug?</p>
                    <p>The other thing to notice is that this still looks like the imperative way of programming (do
                        this and then do that).
                        However, we do not mutate in place, but apply functions and assign them to new variables.
                    </p>
                </aside>
            </section>

            <section>
                <h3>Statelessly with manual wiring</h3>
                <table>
                    <thead>
                    <tr>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <ul>
                                <li>Simple</li>
                                <li>Immutable</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Error prone</li>
                                <li>Extra argument for every state manipulating function</li>
                            </ul>
                        </td>
                    </tr>
                    </tbody>
                </table>

                <aside class="notes">
                    <p>
                        Now we have seen the basic pattern for changing a stateful API to a purely functional API.
                        The key to recovering referential transparency is to make the state updates explicit.
                        So we pass in the old state, return the new state and the value if that exists and leave the old
                        state unchanged.
                    </p>
                    <p>Note: manual, explicit wiring of state through all the calls is error-prone as we have seen</p>
                </aside>
            </section>
        </section>
        <!-- EOF Introducing immutability -->

        <!-- Using a Functional State Data Structure -->
        <section>
            <section>
                <h2>Functional State</h2>
                <aside class="notes">
                </aside>
            </section>


            <section>
                <h3>Let's look at the type signature</h3>

                <pre><code class="scala" data-noescape>
def turn(m: Machine): (Machine, Candy)
                </code></pre>
            </section>

            <section>
                <h3><code class="scala">Machine => (Machine, Candy)</code></h3>
                <aside class="notes">
                    We are separating the declaration of the manipulation and the computation/the moment that the
                    manipulation is applied.
                </aside>
            </section>

            <section>
                <h3><code class="scala">S<span style="color: red" class="fragment" data-fragment-index="1">1</span> =>
                    (S<span style="color: red" class="fragment" data-fragment-index="1">2</span>, A)</code></h3>
                <aside class="notes">
                    Or more abstract, we got a function that takes something that represents the State with an output
                    of a tuple of a new State and a value.
                    So we have a function from a State to a new State and a value.
                </aside>
            </section>

            <section>
                <h3>Let's wrap this in a class</h3>

                <pre><code class="scala" data-noescape>      
class State[S, +A](f: S => (S, A)) {
        
  def run(initial: S): (S, A) = f(initial)
        
}
            </code></pre>
                <aside class="notes">
                    NB: <code class="scala">new State(f).run(s) == f(s)</code>
                    <p>
                        TODO should we get rid of the +A covariance for simplicity?
                        So we have a class State with two Type parameters S and A for the State and the value.
                        The constructor of the class does not take a regular value, but it takes that function
                        from a State to a new State and value.
                    </p>
                    <p>
                        Creating the State does not do anything useful yet.
                        Run will just apply/invoke that function and thus return a tuple of a new state and a value.
                    </p>
                    <p>
                        Without combinators the class does not do much of course.
                        We need the class because unlike JavaScript we cannot add methods to functions.
                    </p>
                </aside>
            </section>

            <section>
                <h3>Refactor the current turn method</h3>
                <pre class="fragment fade-out"
                     style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;"
                     data-fragment-index="0"><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
  def turn(m: Machine): (Machine, Candy) = 
    (m.copy(candies = m.candies.tail), m.candies.head)
                </code></pre>
                    <pre class="fragment fade-in"
                         style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;"
                         data-fragment-index="0"><code class="scala" data-noescape>      
case class Machine(coins: Int, candies: List[Candy])

object Machine {
  def turn(): State[Machine, Candy] = <span class="fragment fade-out">new </span>State(m => 
    (m.copy(candies = m.candies.tail), m.candies.head)
  )
                </code></pre>
                <aside class="notes">
                    If we add an apply function we can even remove the 'new'
                    And again, calling Machine.turn() does not do anything. It just defines a function that will
                    do something WHEN it is applied with a machine.
                    This is shown below, when the run method is called with a machine, then the result is calculated.
                </aside>
            </section>

            <section>
                <h3>Ok, but what about inserting a Coin?</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin<span class="fragment" data-fragment-index="2">)</span><span class="fragment fade-out"
                                                                                        data-fragment-index="2">,</span><span
                        class="fragment" data-fragment-index="2">(</span>m: Machine): <span class="fragment"
                                                                                            data-fragment-index="1">(</span>Machine<span
                        class="fragment" data-fragment-index="1">, Unit)</span>
                 </code></pre>
                <aside class="notes">
                    <p>This does not look like a function S => (S,A),
                        but looking at it more abstractly: the return value from insertCoin is nothing or Unit.</p>

                    <p>And if we are going to use currying of the parameters, we get two parameter lists, with one
                        that is equal to the State datatype we created.
                        Currying is named after Haskell Brooks Curry , who was an American mathematician and logician.
                        It is the technique of translating the evaluation of a function that takes multiple arguments
                        (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.
                        In this case we change a function that takes two parameters and returns a tuple of Machine and
                        Unit
                        to a function with one parameter (Coin), that returns a function that takes one parameter and
                        returns a tuple of Machine and Unit.
                    <p>So, here we can also refactor it to use the State data type we created.
                    </p>
                </aside>
            </section>

            <section>
                <h3>Let's refactor this as well</h3>
                <pre class="fragment fade-out"
                     style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;"
                     data-fragment-index="0"><code class="scala" data-noescape>
def insertCoin(coin: Coin) (m: Machine): (Machine, Unit) =
  ( m.copy(coins = m.coins + 1), () )

                </code></pre>
                    <pre class="fragment fade-in"
                         style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;"
                         data-fragment-index="0"><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = State(m =>
    ( m.copy(coins = m.coins + 1), () )
  )

                </code></pre>
                    <aside class="notes">
                        So inserting a coin basically return a datatype holding a function that will take a machine as a
                        parameter and return a new machine with increased number of coins and no concrete return value.
                    </aside>
            </section>

            <section data-background-image="img/camron_u_mad.jpg">
                <h3>Now hold on a minute...</h3>
                <h4>Didn't you just make it more complex?</h4>
                <aside class="notes">
                    Yes we did make it more complex, but...
                    This allows us to use combinators (which allow us to rewrite this into something nicer)
                    Background: u mad meme: http://nymag.com/selectall/2015/12/nine-canonical-responses-to-u-mad.html
                </aside>
            </section>
        </section>
        <!-- EOF Using a Functional State Data Structure -->

        <!-- Combinators -->
        <section>
            <section>
                <h2>Combinators</h2>
                <blockquote>"A combinator is a higher-order function <br/>
                    that uses only function application and<br/>
                    earlier defined combinators<br/>
                    to define a result from its arguments."
                </blockquote>
                <aside class="notes">
                    Note: from https://en.wikipedia.org/wiki/Combinatory_logic
                </aside>
            </section>

            <section>
                <h3>map</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def map[B](transform: A => B): State[S, B] <span class="fragment" data-fragment-index="2">=
    new State[S, B](s0 => {
      val (s1, a) = run(s0)
      (s1, transform(a))
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----                    
         |   | -----------------------> s1 
   s0 -> | f |         -------------         
         |   | -> a -> | transform | ->  b
         -----         -------------         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now it's getting interesting. What if we want to combine and transform the value.
                    What if we, when running the state function would like to transform the resulting value.
                    Just like with a List we can do that with the map function.
                    How does it look like graphically? We have a machine that we give to the run-function of the State
                    (which basically applies f to s0).
                    The run function delivers a new State (machine) and a value 'a'. The value a is transformed by the
                    map-function to a b.
                </aside>
            </section>
            <section>
                <h3>Spin it</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val turn   : State[Machine, Candy] = Machine.turn()
val program: State[Machine, String] = turn.map(_.color)
val (m1, color) = program.run(m0)

color shouldBe "Blue"
                </code></pre>
                <aside class="notes">
                    So we have now a new function that combines the turn function with a function that transforms the
                    resulting output.
                    And we can write this more succintly as the Scala compiler can infers most types.
                </aside>
            </section>

            <section>
                <h3>Or more ideomatic</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, candies)

val program = turn().map(_.color)
val (m1, color) = program.run(m0)
      
color shouldBe "Blue"
                </code></pre>
            </section>

            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
class State[S, +A](f: S => (S, A)) {
                    
  def flatMap[B](g: A => State[S, B]): State[S, B] <span class="fragment" data-fragment-index="2">=
    State(s0 => {
      val (s1, a) = run(s0)
      g(a).run(s1)
    })
</span>
<span class="fragment" data-fragment-index="1">
         -----           -----         
         |   | ->  s1 -> |   | -> s2 
   s0 -> | f |           | g |         
         |   | ->   a -> |   | -> b
         -----           -----         
</span>
                </code></pre>
                <aside class="notes">
                    Ok, now looking at flatMap.
                    So the state function takes a state (think machine) and the resulting output of running is a
                    modified state and an a.
                    The function g takes an a and returns a State[S,B]. But a State is just a function from S => (S,A).
                    So in the end we first have to feed the function g an 'a', so we get a new State function.
                    And then 'run' the State function by providing the new State 's' that was the result of running the
                    f-function.
                    This gives us the return value: a tuple of (S,B).

                    Implementing this now, is a piece of cake (a big piece, that is ;-))
                    TODO: 'g' in the ascii art is not entirely correct, applying g(a) gives us a State[S,B]. As we
                    are already wrapping it in a new create State, we would get State[State,B]..?], so the resulting
                    State[S,B] should be run so the function that is wrapped is a 'S => (S,B).
                    Hoe kunnen we dat uitdrukken???
                </aside>
            </section>
            <section>
                <h3>FlatMap chains two state functions</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, List(Candy("Blue"), Candy("Red"), ...))

val program = insertCoin(Coin)
                     .flatMap(_ => turn())
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Blue")
                </code></pre>
                <aside class="notes">
                    We have been lying until now, the domain prescribes that we insert a coin first.
                    Remember we get a State[Machine, Unit) as a result. And then we want to turn the machine.
                    As we are not interested in the resulting value of insertCoin (Unit) we disregard the parameter.
                    The State (or the Machine) will be used in the flatMap function.
                    In the end the resulting return type of turn is the State[Machine, Candy], so we know the last
                    validation is successful.
                    Here you see how the state is automatically threaded through the different functions by using the flatMap function.
                </aside>
            </section>
            <section>
                <h3>This quickly gets cumbersome</h3>
                <pre><code class="scala" data-noescape>
val m0 = Machine(0, List(Candy("Blue"), Candy("Red"), ...))

val program =
  insertCoin(Coin)
    .flatMap(_ => turn()
      .flatMap(_ => insertCoin(Coin)
        .flatMap(_ => turn())))
val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                    Note how we disregard intermediate values. That is because we are only interested
                    in the end result. This can be a bit confusing. We are not throwing away an end 
                    result, we just describe how different functions are chained together. To chain the
                    functions though, we do not need the value produced by the previous one.

                    <code class="scala">
                    val s1 = new State[String, Int](s => (s, s.length))
                        .flatMap[Int](length => new State[String, Int](s => (s, 2 * length)))
                    </code>
                </aside>
            </section>


            <section>
                <h3>Using for comprehensions</h3>
                <pre><code class="scala" data-noescape>
val program = for {
  _ <- insertCoin(Coin)
  _ <- turn()
  _ <- insertCoin(Coin)
  candy <- turn()
} yield candy

val (m1, candy) = program.run(m0)

candy shouldBe Candy("Red")
                </code></pre>
                <aside class="notes">
                    For those familiar with Scala know that flatMaps can be elegantly replaced with a for-comprehension.
                </aside>
            </section>
            
            <section>
                <h3>FP with Getters and Setters</h3>
                <aside class="notes">
                    That for code already looks more imperative. But can we make it even more imperative?
                    Yes! Welcome our old friends getter and setter!
                </aside>
            </section>
            <section>
                <h3>Now what if we just want to get the state?</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def get[S]: State[S, S] = State(s => (s, s))
  ...
}
                </code></pre>
            </section>
            <section>
                <h3>And with get comes set</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def set[S](newS: S): State[S, Unit] = State(_ => (newS, ()))
  ...
}
                </code></pre>
            </section>
            <section>
                <h3>Doing the refactoring</h3>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] =
    State(m => (m.copy(coins = m.coins + 1), ()))
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = for {
  m <- State.get[Machine]
  u <- State.set(m.copy(coins = m.coins + 1))
} yield u
                </code></pre>
            </section>

            <section>
                <h3>Get and Set == Modify</h3>
                <pre><code class="scala" data-noescape>
object State {
  ...  
  def modify[S](f: S => S): State[S, Unit] = 
                    State(s => (f(s), ()))
  ...
}
                </code></pre>
                <pre><code class="scala" data-noescape>
def insertCoin(coin: Coin): State[Machine, Unit] = 
  State.modify(m => m.copy(coins = m.coins + 1))
                </code></pre>
            </section>

        </section>
        <!-- Combinators -->
        <section>
            <h3>Automatic wiring with State datatype</h3>
            <table>
                <thead>
                <tr>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>
                        <ul>
                            <li>Simple</li>
                            <li>Immutable</li>
                            <li>Automatic state wiring</li>
                            <li>For-comprehension</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Performance impact</li>
                        </ul>
                    </td>
                </tr>
                </tbody>
            </table>

            <aside class="notes">
                <p>Simple in the sense we are still passing around functions and there are no special Scala constructs
                    used like implicit, type level programming and such.
                    It is not simple if you are not used to this style.
                </p>
            </aside>
        </section>
        <section>
            <h3>The State data type</h3>
            <ul>
                <li>simplifies computations involving state</li>
                <li>while maintaining referential transparency</li>
            </ul>
        </section>


        <section>
            <h2>References</h2>
            <ul>
                </li>
                <li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in
                    Scala</a></li>
                <li><a href="https://www.youtube.com/watch?v=Jg3Uv_YWJqI)">Michael Pilquist - Scalaz State Monad</a>
                </li>
                <li><a href="https://www.youtube.com/watch?v=XxzzJiXHOJs](https://www.youtube.com/watch?v=XxzzJiXHOJs">Brian
                    Beckman: The Zen of Stateless State - The State Monad</a></li>
            </ul>
        </section>
        
        <section>
            <h2>The end</h2>
            
            <p>Presentation is available on <br />
                <a href="https://github.com/aggenebbisj/functionalstate">https://github.com/aggenebbisj/functionalstate</a>
            </p>
        </section>

        <section data-background-image="img/the_coming_curse_by_mistabobby1.jpg">
            <h2>Monadic Curse</h2>
            <blockquote>
                once someone learns what monads are
                and how to use them, <br/>
                they loose the ability <br/>
                to explain it to other people.

            </blockquote>
            <a href="https://www.youtube.com/watch?v=b0EF0VTs9Dc">Douglas Crockford</a>
            <aside class="notes">
                [Monads and Gonads - Douglas Crockford](https://www.youtube.com/watch?v=b0EF0VTs9Dc)
                image from
                https://contemporaryshaman.files.wordpress.com/2013/11/the_coming_curse_by_mistabobby1.jpg
            </aside>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
         center: false,
         width: '100%', 

        history: true,

        chalkboard: {
            // optionally load pre-recorded chalkboard drawing from file
            // src: "foo.json",
        },

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/chalkboard/chalkboard.js'}
        ],
        keyboard: {
            67: function () {
                RevealChalkboard.toggleNotesCanvas()
            },    // toggle notes canvas when 'c' is pressed
            66: function () {
                RevealChalkboard.toggleChalkboard()
            }, // toggle chalkboard when 'b' is pressed
            46: function () {
                RevealChalkboard.clear()
            },    // clear chalkboard when 'DEL' is pressed
            8: function () {
                RevealChalkboard.reset()
            },    // reset chalkboard data on current slide when 'BACKSPACE' is pressed
            68: function () {
                RevealChalkboard.download()
            }, // downlad recorded chalkboard drawing when 'd' is pressed
        }
    });
</script>
</body>
</html>
